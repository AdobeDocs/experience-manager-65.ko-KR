---
title: AEM에 기여
seo-title: AEM에 기여
description: AEM은 대규모 오픈 소스 프로젝트에서 일반적으로 수행되는 검증된 방법론에 따라 개발되었습니다.
seo-description: AEM은 대규모 오픈 소스 프로젝트에서 일반적으로 수행되는 검증된 방법론에 따라 개발되었습니다.
uuid: ffef60ae-8a9a-4c4b-8cbd-3cd72792a42e
contentOwner: Guillaume Carlino
products: SG_EXPERIENCEMANAGER/6.5/SITES
topic-tags: introduction
content-type: reference
discoiquuid: f52402df-f6dc-4c62-82bc-cbce489b2b74
translation-type: tm+mt
source-git-commit: a3c303d4e3a85e1b2e794bec2006c335056309fb

---


# AEM에 기여{#contributing-to-aem}

## 개발 방법론 {#development-methodology}

AEM 파섹 AEM 기술 스택의 많은 핵심 요소는 실제로 Apache Software Foundation에 기여한 Sling 및 Jackrabbit과 같은 활성 오픈 소스 프로젝트로 유지됩니다. AEM에 있는 이러한 정신의 주된 특징은 개발 팀과의 직접적인 상호 작용을 위해 사용 가능한 메일링 목록과 온라인 포럼을 사용하는 것이 좋다는 것입니다.

AEM의 구성 요소에 기여하는 경우, 오픈 소스 프로젝트에 기여할 때와 같이 AEM에 익숙해지며, 프로젝트에 기여할 때와 같이 기존 핵심 팀과 커뮤니케이션해야 합니다.

## 필수 경험 {#required-experience}

HTTP(HyperText Transfer Protocol)는 모든 작업을 지원합니다. 따라서 AEM에 게시하기 전에 스레드 풀링을 사용하여 자체 Java 구현을 작성할 수 있는 범위 내에서 HTTP에 대한 심층적인 이해를 가져야 합니다. 또한 HTTP/1.1의 지속적인 동작에 대한 이해를 가지고 있어야 하며 JavaScript와의 서버/클라이언트측 상호 작용, 특히 AJAX로 표현되는 비동기 인터랙션에 대한 심도 있는 지식이 있어야 합니다.

페이지 다이내믹함과 인터랙티브한 컨텐츠는 WM 경험의 핵심이기 때문에 문서 객체 모델과 이벤트에 대한 프로그래머틱 조작에 대한 잠재력을 상당히 깊이 있게 이해하는 것이 중요합니다. 예를 들어 여러 브라우저 문서(예: iframe 사용)에 대한 실시간 DOM 조작 및 드래그 앤 드롭 동작에 대해 알고 있어야 합니다.

가장 높은 수준에서 다음을 명확하게 이해해야 합니다.

* HTTP [/1.1 프로토콜](https://www.ietf.org/rfc/rfc2616.txt)
* HTML(가급적이면 [HTML5](https://dev.w3.org/html5/spec/Overview.html))
* 계단식 스타일 시트
* XML(Extensible Markup Language)
* 비동기 JavaScript 및 XML(AJAX) 디자인 패턴
* JavaScript 개체 표기법(JSON)
* 문서 객체 모델
* 상태 저장 및 상태 비저장 상호 작용
* [동일한 리소스 식별자](https://www.ietf.org/rfc/rfc2396.txt)
* 브라우저 쿠키
* 및 기타 최신 웹 개발 개념

Adobe Experience Manager의 기술 스택은 Apache [Sling](https://felix.apache.org/) 웹 프레임워크가 포함된 Apache Felix OSGI [컨테이너를 기반으로 하며](https://sling.apache.org/site/index.html) Apache Jackrabbit[를](https://docs.adobe.com/content/docs/en/spec/jcr/2.0/index.html)기반으로 Java Content Repository( [JCR)를](https://jackrabbit.apache.org/jcr-api.html)포함합니다. 귀하는 이러한 개별 프로젝트와 증여하려는 영역에 사용되는 다른 모든 오픈 소스 구성 요소(예: Apache Lucene)에 익숙해져야 합니다.

## 부족 지식 {#tribal-knowledge}

어떤 개념과 가이딩 원리는 전 날의 문화에 깊이 스며들어 있습니다. 이 섹션에서는 알아야 할 &quot;깊이 있는 DNA 포함&quot; 문제 중 일부를 나열합니다.

### 모든 것이 컨텐츠임 {#everything-is-content}

컨텐츠에는 웹 응용 프로그램이 지속되는 모든 데이터만 포함됩니다. 프로그램 코드, 라이브러리, 스크립트, 템플릿, HTML, CSS, 이미지 및 모든 종류의 아티팩트는 컨텐츠 저장소에 보관되며 패키지 관리자 및 패키지 공유를 통해 패키지 형태로 가져오거나 내보냅니다.

### David&#39;s Model {#david-s-model}

Java Content Repository에서 컨텐츠를 모델링하는 방식은 관계형 환경에서 데이터 모델링을 위해 소프트웨어 업계에서 일반적으로 사용되는 방식과 완전히 다른 사고방식을 필요로 합니다. JCR 방식은 컨텐츠 관리 분야의 새로운 [직원에게 없어서는 안 될 책입니다.컨텐츠 모델링을](https://wiki.apache.org/jackrabbit/DavidsModel)위한 가이드입니다.

### REST 파섹 {#restfulness}

REST 방식은 우리가 하는 일에 깊이 뿌리내리고 있습니다. 즉, URI가 컨텐츠 및 서비스에 대한 결정적인 주소라는 점을 명심하고, 상태 저장 상호 작용을 피한다는 의미입니다.

REST(Representational State Transfer)는 World Wide Web의 기반이 되는 소프트웨어 아키텍처 스타일을 나타냅니다. 웹 작업을 가능하게 하는 주요 요소에 대해 설명하고 웹 기반 소프트웨어의 설계 방법에 대한 일련의 원칙을 제공합니다. 웹을 통해 사용할 API를 디자인할 때 이러한 &quot;모범 사례&quot;를 따르는 것이 적절합니다.

REST는 Adobe가 수행하는 대부분의 작업에 대한 안내 철학을 제공하므로 RESTful 디자인의 분야에 정통한 사람이 되기 위해서는 반드시 고려해야 합니다. 좋은 출발점은 로이 [필더스의 논문으로](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm)시작한다.

### Sling 요청 해결 {#sling-request-resolution}

AEM에 대해 이해하는 주요 측면은 들어오는 요청이 컨텐츠 및 애플리케이션 비헤이비어와 어떻게 관련되는지, 컨텐츠 저장소에서 컨텐츠가 구조화되어 있는지, 그리고 AEM이 요청을 처리하는 애플리케이션 로직을 찾는 방법입니다. Apache Sling URL [분해](https://sling.apache.org/site/url-decomposition.html) 및 REST 아키텍처 스타일과 비상태, 캐시 가능 및 계층화된 시스템 제약 조건을 적용하는 방법에 대해 알아봅니다.

Apache Sling의 요청 해상도에 대한 주요 이해 사항은 요청이 컨텐츠 저장소의 특정 리소스에 주로 매핑되는 방식, 요청의 추가 속성이 이러한 컨텐츠 객체의 속성과 함께 어떻게 컨텐츠를 렌더링하기 위해 호출될 응용 프로그램 코드 및 /apps의 코드가 /libs의 코드를 재정의하는 방식입니다.

### 빠른 시작 {#quickstart}

3단계 없음:Quickstart JAR 파일을 두 번 클릭하여 설치하여 실행하면 됩니다. 3단계는 아닙니다. 추가 옵션 기능은 패키지 공유에서 해당 패키지를 설치하는 것 외에는 필요하지 않습니다.

작은 빠른 시작 크기:Quickstart JAR 파일의 크기를 최소 크기로 유지합니다. 라이브러리를 지능적이고 최적화된 상태로 사용할 수 있고 옵션 기능을 이동하여 공유할 수 있습니다.

더욱 빨라진 시작 시간:시작 시간에 영향을 줄 수 있는 변경 사항을 적용할 때 더 이상 단축되지 않도록 합니다.

### Lean and Mean {#lean-and-mean}

Adobe는 작지만 빠르고 세련된 코드 및 프로젝트를 선호합니다. &quot;충분히 좋다&quot;는 것은 충분하지 않다.

코드 재사용:OSGi 기반의 제품 아키텍처와 &quot;모든 것이 컨텐츠임&quot; 철학은 코드 및 객체를 재사용할 수 있는 매우 좋은 기회를 보유하고 있음을 의미합니다. 우리는 그 사실을 최대한 활용하기 위해 전력을 다하고 있다.

느슨한 연결:우리는 긴밀한 의존성과 &quot;원치 않는 친밀성&quot;에 대한 느슨하게 결합된 상호작용을 좋아한다. 느슨한 연결로 더 많은 코드를 재사용할 수 있습니다.

### 데모 중단 안 함 {#don-t-break-the-demo}

데모 스크립트 및 데모에 가장 자주 표시되는 제품 기능에 익숙해지십시오. 최소한 &quot;데모 스크립트&quot; 기능을 중단해서는 안 됩니다. 핵심 제품은 개발 중에도 항상 데모를 준비할 수 있어야 합니다.

### 안정성을 위한 디자인 {#design-for-reliability}

예를 들어 단일 DOM 요소에 문제가 발생하면 전체 페이지가 렌더링되지 않도록 fail-soft 방식으로 디자인 및 코드 기능을 디자인하고 코드를 작성하려고 합니다. 즉,치명적일 수 있는 것을 만들어라. 모든 것을 안전하게 유지 &quot;용서&quot;한 제품 제작

### 새로운 표준이 비정상이다 {#abnormal-is-the-new-normal}

종료 후크에 의존하지 말고 시작 시 정리가 가능합니다. 비정상적인 종료는 정상적인 종료입니다.

`shutdown == kill -9 == power outage`

### 탄력적인 클러스터링 준비 {#be-ready-for-elastic-clustering}

항상 탄력적인 클러스터링을 준비할 수 있으므로 항상 클러스터링이 있다고 가정합니다. 일반적으로 컨텐츠 저장소에 있는 모든 것을 그대로 유지하는 것은 클러스터링 지원에 내장되어 있습니다.

### 이전 버전과의 호환성을 위한 디자인 {#design-for-backward-compatibility}

고객의 기존 코드를 어기는 일은 없습니다. 업그레이드 `/libs` 중에 업데이트할 수 있는 제품 코드만 포함하는 것이 좋습니다. 저장소의 `/apps` 섹션은 프로젝트 코드이며, `/etc` 섹션에는 보존해야 하는 사용자 정의 구성이 포함되어 있습니다. 일반적으로 에 있는 `/apps`내용을 덮어쓰지 `/content` 마십시오 `/home`. 업그레이드 후 이전 프로젝트 코드, 구성 및 컨텐츠는 업그레이드 전과 같이 계속 작동해야 합니다.

이전 버전과의 호환성을 위해 설계하면 업그레이드 경험이 초기 설치의 간편성과 일치할 수 있습니다. AEM을 중지하거나 Quickstart JAR 파일을 교체하고 AEM을 다시 시작하면 충분합니다. 설치 기반이 급속도로 증가함에 따라 업그레이드 효율성이 점점 더 높아질 것입니다.

기존 API는 최신 API를 대체할 때 더 이상 사용되지 않으며, 더 나은 기능으로 표시되어야 하지만, 이전 5.x 릴리스에서 공개된 모든 API는 사용자 지정 애플리케이션 코드에서 사용 중이기 때문에 계속 기능해야 합니다. 이러한 API는 제거할 필요가 없습니다.

컨텐츠 구조와 사용자 경험의 일반적인 일관성과 관련하여 이전 버전과의 호환성을 고려해야 합니다.

## 핵심 개념 {#core-concepts}

**작성자 인스턴스** - 일반적으로 보안, 거버넌스 및 기타 이유로 제작 사이트는 AEM 인스턴스를 작성자 및 게시 인스턴스로 나눕니다. 배포 아키텍처(작성자/게시 인스턴스 포함)에 대한 자세한 내용은 AEM 인스턴스에 대한 설명서를 참조하십시오.

**캐싱, 튀김 및 굽기** - 일반적으로 굽기와 튀김의 개념은 서로 다른 웹 컨텐츠 관리 시스템 간의 중요한 차이점입니다. CMS 용어로 &quot;bing&quot;은 퍼블리시 정적 파일에 데이터를 커밋하는 개념을 의미하고, &quot;blay&quot;는 요청 시 최종 프레젠테이션을 위해 데이터를 처리하는 개념(즉, 적시에)을 의미합니다.

**클러스터링 및 로드 밸런싱** - 프로덕션 환경의 가용성을 높이고 성능을 향상시키기 위해 여러 작성자 및/또는 게시 인스턴스를 여러 사용자 그룹에 사용할 수 있도록 하거나 Dispatcher 구성 뒤에서 로드 밸런싱을 통해 클러스터로 결합하는 것이 일반적입니다.

또한 컨텐츠 저장소의 여러 인스턴스를 결합하여 *고가용성* JCR 솔루션을 만들 수 있으며, 이를 AEM 솔루션과 통합하여 하드웨어 및 소프트웨어 장애에 대한 보호를 극대화할 수 있습니다. 자세한 [내용은 권장](/help/sites-deploying/recommended-deploys.md#oak-cluster-with-mongomk-failover-for-high-availability-in-a-single-datacenter) 배포를 참조하십시오.

**구성 요소** - AEM에서 구성 요소는 일반적으로 사이드 킥에서 드래그 앤 드롭하여 만들 수 있는 객체 유형입니다. 예를 들어 AEM과 함께 제공되는 기본 구성 요소에는 런타임 시 사이드 킥에서 사용할 수 있는 텍스트, 제목, 태그 클라우드, 캐러셀, 이미지 및 목록 구성 요소가 포함되어 있습니다.

**컨텐츠 파인더** - 작성 모드에서 컨텐츠 파인더는 페이지의 왼쪽에 있는 특수 패널(프레임)으로, 맨 위에 선택한 탭에 따라 컨텐츠 파인더에서 오른쪽 페이지로 드래그하여 놓을 수 있는 이미지, 문서, Flash 자산, 페이지, 단락 또는 저장소 리소스 목록을 표시합니다.

**디지털 자산** - AEM에서 디지털 자산은 (일반적으로) 이미지와 리치 미디어 파일입니다. 자세한 내용은 DAM 파섹

**디스패처** - 디스패처는 캐싱 및 로드 밸런싱 도구일 뿐만 아니라 특정 보안 보호 기능을 제공합니다.

**ExtJS 위젯** - AEM의 대부분의 사용자 인터페이스 요소는 JavaScript로 작성된 타사 위젯 라이브러리인 ExtJS를 사용합니다. ExtJS는 고성능의 사용자 정의 가능한 UI 위젯과 잘 설계된 확장 가능한 구성 요소 모델을 제공합니다.

**JCR, Java** Content Repository - Java Content Repository 사양(JSR-283)은 추상 데이터 모델과 애플리케이션 프로그래밍 인터페이스를 제공하여 파일 시스템과 객체 데이터베이스의 기능을 결합한 대량 확장 가능한 NoSQL 데이터 저장소를 구현할 수 있도록 합니다. JSR-283을 완전히 세부적으로 이해할 필요는 없지만 JCR의 기본 기능과 AEM의 &quot;모든 것이 컨텐츠&quot;를 가능하게 하는 것이 JCR의 &quot;모든 것이 컨텐츠&quot;인 데이터 모델에 익숙해지려면 시간이 걸릴 수 있습니다.

기본적으로 JCR은 노드 및 속성의 시스템으로, 노드는 다른 노드에서 상속할 수 있고 모든 컨텐츠는 속성 *값으로*&#x200B;저장됩니다. JCR은 일반적인 상속 외에도 여러 상속을 모델링할 수 있는 &quot;mixin&quot; 노드의 개념을 허용합니다.

JCR은 사전 정의된 노드 유형과 속성 유형을 다수 보유하고 있지만 일반적으로 입력 시스템은 매우 유연하며, (실제로) JCR의 장점 중 하나는 구조화된 컨텐츠뿐만 아니라 구조화된 컨텐츠를 동일한 방식으로 저장/관리할 수 있다는 것입니다. 즉, JCR은 고도로 구조화된 데이터를 수용할 수 있지만 스키마 제약 없이 임의의 동적 데이터 구조를 수용할 수도 있습니다.

JCR의 Java API용 JavaDoc가 [여기에](http://jackrabbit.apache.org/jcr/jcr-api.html)있습니다.

JavaDoc 또는 JCR 사양을 읽기 전에 Adobe Experience Services에서 구현된 JCR에 대한 [이](/help/sites-developing/the-basics.md#java-content-repository) 수준 높은 설명을 살펴보십시오.

**다중 사이트 관리자(MSM)** - AEM의 MSM 기능을 통해 고객은 다국어 및 다국적 컨텐츠를 처리할 수 있고 로컬라이즈된 컨텐츠와 중앙 브랜딩의 균형을 맞출 수 있습니다.

**OSGi** - OSGi는 AEM에서 모듈화된 Java 개발을 위한 기반을 제공하는 서비스 기반 런타임 기술입니다. 코드 리소스(번들로 알려져 있음)에 대한 높은 동적(안전한) 클래스 로딩 및 실행 환경을 제공할 뿐만 아니라 번들에 의해 노출된 다양한 서비스의 가시성과 라이프사이클을 완벽하게 제어하는 프레임워크입니다. 서비스 레지스트리는 라이프사이클(및 버전 요구 사항)를 고려하는 번들에 대한 협력 모델을 제공합니다. OSGi는 애플리케이션 서버가 해결하려고 했던 많은 문제를 해결했지만, 크기가 작고 동적인 방식으로 해결되어, 예를 들어, 핫-배포 서비스를 가능하게 했습니다(서버를 다시 시작하지 않고 새로운 코드를 즉시 사용 가능).

**Parsys, Paragraph** System - 단락 시스템(parsys)은 작성자가 페이지에 서로 다른 유형의 구성 요소를 추가하고 다른 단락 구성 요소를 포함할 수 있는 복합 구성 요소입니다. 각 단락 유형은 구성 요소로 표현됩니다. 단락 시스템 자체도 하나의 구성 요소이며, 다른 모든 단락 구성 요소를 포함합니다.

**마이크로커널** - 저장소의 모든 작업 영역은 데이터를 특정 마이크로커널(데이터 읽기 및 쓰기를 관리하는 클래스)을 통해 저장하도록 별도로 구성할 수 있습니다. 마찬가지로 저장소 전체 버전 저장소는 특정 마이크로커널을 사용하도록 독립적으로 구성할 수도 있습니다. 다양한 마이크로케널을 사용할 수 있으며 다양한 파일 포맷 또는 관계형 데이터베이스에 데이터를 저장할 수 있습니다. (예를 들어, MongoDB, DB2 또는 Oracle에 대한 지속성 관리자가 있습니다) AEM에 대한 기본 마이크로커널은 TarMK입니다(아래 참조).

**게시 인스턴스** - 보안, 거버넌스 및 기타 이유로 제작 사이트는 일반적으로 AEM 인스턴스를 작성자 및 게시 인스턴스로 나눕니다. 배포 아키텍처(작성자/게시 인스턴스 포함)에 대한 자세한 내용은 AEM 인스턴스에 대한 설명서를 참조하십시오.

**Quickstart** - 다른 많은 프로그램과 달리, 단일 &quot;Quickstart&quot; 자동 압축 해제 JAR 파일을 사용하여 AEM을 설치합니다. JAR 파일을 처음 두 번 클릭하면 필요한 모든 것이 자동으로 설치됩니다. 빠른 시작 JAR에는 CRX 저장소(관리 시설 포함), 가상 저장소 서비스, 인덱스 및 검색 서비스, 워크플로우 서비스, 보안 및 웹 서버에 필요한 모든 파일과 CQSE(CQ Servlet Engine) 및 모든 AEM 서비스가 포함됩니다. 설치할 다른 파일이 없습니다.quickstart는 자체 포함되어 있습니다.

Quickstart를 처음 시작하면 백그라운드에서 전체 JCR 호환 저장소가 생성되므로 몇 분 정도 걸릴 수 있습니다. 이 초기 시작 후, 저장소 인프라가 이미 정리되었기 때문에 후속 신생 기업이 훨씬 더 빨라졌습니다.

많은 시작 옵션(예: 활성 포트 번호 및 해당 AEM 인스턴스가 게시 인스턴스와 작성자 인스턴스여야 하는지 여부)등)은 Quickstart 파일의 이름을 적절하게 변경하여 제어할 수 있습니다. 이러한 옵션 목록을 보려면 명령줄에서 &quot;-help&quot;를 사용하여 JAR를 실행합니다.

```shell
java -jar <quickstartfilename>.jar -help
```

**복제 에이전트** - 복제 에이전트는 작성자에서 게시 환경으로 컨텐츠를 게시(활성화)하는 데 사용되는 메커니즘으로 AEM의 중심입니다.dispatcher 캐시에서 컨텐츠 플러시;사용자가 생성한 컨텐츠(예: 양식 입력)를 게시 환경에서 작성 환경으로 반환합니다.

**Scaffolding** - Scaffolding을 사용하여 페이지에 대한 구조를 반영하는 필드가 포함된 양식(Scaffold)을 만든 다음 이 양식을 사용하여 이 구조를 기반으로 페이지를 쉽게 만들 수 있습니다.

**세분화** - 사이트 방문자가 사이트를 방문할 때 서로 다른 관심사와 목표를 가지고 있습니다. 방문자의 목표를 이해하고 고객의 기대를 만족시키는 것은 온라인 마케팅에 있어 중요한 성공 전제 조건입니다. 세그멘테이션은 방문자의 세부 사항을 분석하고 특징화하여 이를 달성하는 데 도움이 됩니다.

**사이드 킥은** 편집 가능한 페이지에 표시되는 팔레트와 같은 부동 창으로, 새 구성 요소를 드래그할 수 있으며 페이지에 적용되는 작업을 실행할 수 있습니다.

**SiteCatalyst** - SiteCatalyst는 마케터에게 여러 마케팅 채널에서 모든 온라인 이니셔티브의 통합 데이터를 측정, 분석 및 최적화할 수 있는 단일 장소를 제공합니다. Adobe SiteCatalyst를 사용하여 AEM 웹 사이트의 데이터를 분석할 수 있습니다.

**Tar 스토리지(TarMK)** - TarMK는 AEM의 기본 지속성 시스템입니다. AEM은 다른 지속성 시스템(예: MongoDB)을 사용하도록 구성할 수 있지만 TarMK는 일반적인 JCR 사용 사례(매우 빠름)에 맞게 성능이 최적화되어 업계 표준 데이터 형식을 사용하며 빠르고 쉽게 백업할 수 있다는 장점이 있습니다.

**템플릿** - AEM에서 템플릿은 특정 페이지 유형을 지정합니다. 일반적으로 축소판 이미지와 다양한 속성을 지정하는 동안 페이지의 구조를 정의합니다. 예를 들어 제품 페이지, 사이트 맵 및 연락처 정보에 서로 다른 템플릿을 사용할 수 있습니다.

**워크플로우** - AEM 워크플로우 시스템을 사용하면 페이지 또는 자산을 포함하는 자동화된 프로세스를 만들 수 있습니다.
