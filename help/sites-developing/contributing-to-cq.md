---
title: AEM에 기여
seo-title: AEM에 기여
description: AEM은 대규모 오픈 소스 프로젝트에서 일반적으로 수행되는 검증된 방법론에 따라 개발되었습니다.
seo-description: AEM은 대규모 오픈 소스 프로젝트에서 일반적으로 수행되는 검증된 방법론에 따라 개발되었습니다.
uuid: ffef60ae-8a9a-4c4b-8cbd-3cd72792a42e
contentOwner: Guillaume Carlino
products: SG_EXPERIENCEMANAGER/6.5/SITES
topic-tags: introduction
content-type: reference
discoiquuid: f52402df-f6dc-4c62-82bc-cbce489b2b74
translation-type: tm+mt
source-git-commit: a3c303d4e3a85e1b2e794bec2006c335056309fb
workflow-type: tm+mt
source-wordcount: '2726'
ht-degree: 1%

---


# AEM에 기여{#contributing-to-aem}

## 개발 방법론 {#development-methodology}

AEM은 대규모 오픈 소스 프로젝트에서 일반적으로 수행되는 검증된 방법론에 따라 개발되었습니다. AEM 기술 스택의 많은 핵심 요소는 실제로 Apache Software Foundation에 기여한 Sling 및 Jackrabbit과 같은 활성 오픈 소스 프로젝트로 유지 관리됩니다. AEM에서 이러한 정신을 주요 측면에서 볼 때 개발 팀과의 직접적인 상호 작용을 위해 이용 가능한 메일링 목록과 온라인 포럼을 활용할 수 있습니다.

AEM의 구성 요소에 기여하고 있는 경우 오픈 소스 프로젝트에 참여할 때와 같이 AEM에 익숙해지도록 하고 해당 프로젝트에 기여하려는 때와 같이 기존 핵심 팀과 커뮤니케이션해야 합니다.

## 필수 경험 {#required-experience}

HTTP(HyperText Transfer Protocol)는 모든 작업의 핵심입니다. 따라서 AEM에 게시하기 전에 스레드 풀링을 사용하여 다중 스레드 HTTP 서버의 자체 Java 구현을 작성할 수 있는 범위 내에서 HTTP에 대한 심층적인 이해가 있어야 합니다. 또한 HTTP/1.1의 지속적인 동작에 대해서도 알고 있어야 하며 JavaScript와의 서버/클라이언트측 상호 작용, 특히 AJAX에서 나타내는 비동기 인터랙션 스타일에 대한 심도 있는 지식이 있어야 합니다.

페이지 동적 및 인터랙티브한 컨텐츠는 WM 경험의 핵심이기 때문에 문서 객체 모델과 이벤트에 대한 프로그래머틱 조작에 대한 잠재력을 상당히 깊이 있게 이해하는 것이 중요합니다. 예를 들어 여러 브라우저 문서(예: iframe 사용)에서 실시간 DOM 조작 및 드래그 앤 드롭 비헤이비어에 대해 알고 있어야 합니다.

그러면 가장 높은 수준에서 다음을 명확하게 이해해야 합니다.

* [HTTP/1.1 프로토콜](https://www.ietf.org/rfc/rfc2616.txt)
* HTML(가급적이면 [HTML5](https://dev.w3.org/html5/spec/Overview.html))
* CSS(Cascading Style Sheet)
* XML(Extensible Markup Language)
* 비동기 JavaScript 및 XML(AJAX) 디자인 패턴
* JSON(JavaScript Object Notation)
* 문서 객체 모델
* 상태 저장 상호 작용 및 상태 비저장 상호 작용
* [동일한 리소스 식별자](https://www.ietf.org/rfc/rfc2396.txt)
* 브라우저 쿠키
* 및 기타 최신 웹 개발 개념

Adobe Experience Manager의 기술 스택은 [Apache Felix](https://felix.apache.org/) 웹 프레임워크가 포함된 OSGI 컨테이너를 기반으로 하며 [Apache Jackrabbit](https://jackrabbit.apache.org/jcr-api.html)을 기반으로 Java 컨텐츠 저장소([JCR](https://docs.adobe.com/content/docs/en/spec/jcr/2.0/index.html))를 포함합니다. ](https://sling.apache.org/site/index.html)[ 귀하는 이러한 개별 프로젝트와 증여하려는 영역에 사용되는 다른 모든 오픈 소스 구성 요소(예: Apache Lucene)에 대해 숙지해야 합니다.

## 부족 지식 {#tribal-knowledge}

어떤 개념과 원칙은 전 날의 문화에 깊이 스며들어 있다. 이 섹션에서는 알아야 할 &quot;깊이 있는 DNA 포함&quot; 문제들 중 몇 가지를 나열합니다.

### 모든 것이 {#everything-is-content}입니다.

컨텐츠에는 웹 응용 프로그램이 지속되는 모든 데이터만 포함됩니다. 프로그램 코드, 라이브러리, 스크립트, 템플릿, HTML, CSS, 이미지 및 모든 종류의 아티팩트가 컨텐츠 저장소에 보관되고 패키지 관리자 및 패키지 공유를 통해 패키지 형태로 가져오기/내보내집니다.

### David의 모델 {#david-s-model}

Java Content Repository에서 컨텐츠를 모델링하는 방식은 관계형 환경에서 데이터 모델링을 위해 소프트웨어 업계에서 일반적으로 사용되는 방식과 완전히 다른 사고방식을 필요로 합니다. 컨텐츠 관리 분야의 새로운 직원에게 없어서는 안 될 JCR 방법은 [David의 모델입니다.컨텐트 모델링 안내서](https://wiki.apache.org/jackrabbit/DavidsModel).

### RESTness {#restfulness}

REST 방식은 우리가 하는 일에 깊이 배어 있습니다. 이는 무엇보다도, URI가 컨텐츠 및 서비스를 위한 결정적인 주소라는 점을 염두에 두고, 정적 상호 작용을 피하는 것을 의미합니다.

REST(Presentational State Transfer)는 World Wide Web을 기반으로 하는 소프트웨어 아키텍처 스타일을 나타냅니다. 웹 작업을 가능하게 하는 주요 요소에 대해 설명하고 웹 기반 소프트웨어를 설계하는 방법에 대한 일련의 원칙을 제공합니다. 웹에서 사용할 API를 디자인할 때는 이러한 &quot;우수 사례&quot;를 따르는 것이 적절합니다.

REST는 우리가 하는 많은 작업 뒤에 가이딩 철학을 제공하므로 RESTful 디자인을 잘 이해하는 것이 필수적이라고 간주해야 합니다. 출발하기에 좋은 곳은 [로이 피딩의 논문](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm)이다.

### Sling 요청 해상도 {#sling-request-resolution}

AEM에 대해 이해하는 주요 측면은 수신 요청이 컨텐츠 및 애플리케이션 비헤이비어와 어떻게 관련되는지, 컨텐츠 저장소에서 컨텐츠가 어떻게 구조화되는지, 그리고 AEM이 애플리케이션 로직을 찾아 요청을 처리하는 방식입니다. Apache [Sling URL 분해](https://sling.apache.org/site/url-decomposition.html) 및 REST 아키텍처 스타일과 비상태, 캐시 가능 및 레이어로 구성된 시스템 제약 조건을 적용하는 방법에 대해 알아봅니다.

Apache Sling의 요청 해상도에 대한 이해의 주요 점은 요청이 컨텐트 저장소의 특정 리소스에 주로 매핑되는 방법, 이러한 컨텐츠 객체의 속성과 함께 요청의 추가 속성이 컨텐츠를 렌더링하기 위해 호출될 응용 프로그램 코드 및 /apps의 코드가 /libs의 코드를 무시하는 방법입니다.

### 빠른 시작 {#quickstart}

3단계 없음:설치하고 실행하려면 Quickstart JAR 파일을 두 번 클릭하기만 하면 됩니다. 3단계는 아닙니다. 추가적인 선택적 기능은 패키지 공유에서 해당 패키지를 설치하는 것 외에는 필요하지 않습니다.

작은 빠른 시작 크기:Quickstart JAR 파일의 크기를 최소 크기로 유지합니다. 라이브러리를 지능적으로 최적화된 상태에서 패키지 공유를 위한 옵션 기능을 이동할 수 있습니다.

더욱 빨라진 시작 시간:시작 시간에 영향을 줄 수 있는 변경 내용을 만드는 경우 더 이상 단축되지 않도록 하십시오.

### Lean 및 Mean {#lean-and-mean}

Adobe는 작지만 빠르고 세련된 코드 및 프로젝트를 선호합니다. &quot;충분히 좋다&quot;는 것으로는 충분치 않다.

코드 재사용:OSGi 기반의 제품 아키텍처와 &quot;모든 것이 컨텐츠임&quot; 철학은 코드 및 객체를 재사용할 수 있는 매우 좋은 기회를 보유하고 있음을 의미합니다. 우리는 가능한 한 그 사실을 최대한 활용하려고 노력한다.

느슨한 커플링:우리는 긴밀한 의존성과 &quot;원치 않는 친밀성&quot;에 대한 느슨하게 연결된 상호작용을 선호한다. 느슨한 연결로 더 많은 코드를 재사용할 수 있습니다.

### 데모 {#don-t-break-the-demo} 중단 안 함

데모 스크립트와 제품 기능에 대해 잘 알고 있어야 합니다. 최소한 &quot;데모 스크립트&quot; 기능을 깨는 것은 없어야 합니다. 핵심 제품은 개발 중에도 항상 데모를 준비해야 합니다.

### 신뢰성 디자인 {#design-for-reliability}

예를 들어 단일 DOM 요소의 문제 때문에 전체 페이지가 렌더링되지 않도록 fail-soft로 기능을 디자인하고 코드를 작성하도록 노력하고 있습니다. 즉,치명적일 수 있는 것들을 만들어라. 모든 것을 안전하게 유지 &quot;용서받을 수 있는&quot; 제품 만들기

### New Normal {#abnormal-is-the-new-normal}이(가) 이상입니다.

종료 후크에 의존하지 않고 시작 시 정리가 가능합니다. 비정상적인 종료는 정상적인 종료입니다.

`shutdown == kill -9 == power outage`

### 탄력적 클러스터링 {#be-ready-for-elastic-clustering} 준비

항상 탄력적인 클러스터링을 준비할 수 있습니다. 항상 클러스터링이 있다고 가정해 보십시오. 일반적인 규칙으로, 컨텐츠 저장소에 있는 모든 것을 준수한다는 것은 클러스터링 지원에 내장되어 있습니다.

### 이전 버전과의 호환성을 위한 디자인 {#design-for-backward-compatibility}

고객의 기존 코드를 어기는 일은 없습니다. 업그레이드 중에 업데이트할 수 있는 제품 코드를 포함하려면 `/libs`만 고려하십시오. 저장소의 `/apps` 섹션은 프로젝트 코드이고 `/etc` 섹션에는 보존해야 하는 사용자 지정 구성이 포함되어 있습니다. 일반적으로 `/apps`, `/content` 및 `/home`에 있는 것은 덮어쓰지 마십시오. 업그레이드 후 이전 프로젝트 코드, 구성 및 컨텐츠는 업그레이드 전에 모든 것처럼 계속 작동해야 합니다.

이전 버전과의 호환성을 위해 디자인하면 업그레이드 경험이 초기 설치의 간편성과 일치할 수 있습니다. AEM을 중지하고, Quickstart JAR 파일을 교체하고, AEM을 다시 시작하면 충분합니다. 설치 기반이 급속도로 증가하고 있는 상황에서 업그레이드 효율성이 점점 더 높아질 것입니다.

기존 API는 더 최신, 더 나은 기능이 대체할 때 더 이상 사용되지 않는 것으로 표시될 수 있지만, 이전 5.x 릴리스에서 공개된 모든 API는 사용자 지정 애플리케이션 코드에서 사용 중일 수 있으므로 계속 작동해야 합니다. 이러한 API는 제거하지 않아도 됩니다.

컨텐츠 구조와 사용자 경험의 일반적인 일관성과 관련하여 이전 버전과의 호환성을 고려해야 합니다.

## 핵심 개념 {#core-concepts}

**작성자 인스턴스**  - 일반적으로 보안, 거버넌스 및 기타 이유로 프로덕션 사이트에서 AEM 인스턴스를 작성자 및 게시 인스턴스로 나눕니다. 배포 아키텍처(작성자/게시 인스턴스 포함)에 대한 자세한 내용은 AEM 인스턴스에 대한 설명서를 참조하십시오.

**캐싱, 튀김 및**  굽기 - 일반적으로 굽기와 튀김의 개념은 서로 다른 웹 컨텐츠 관리 시스템 간의 중요한 차이입니다. CMS 전문 용어에서는 &quot;bing&quot;은 퍼블리시(publish-time)에 정적 파일에 데이터를 커밋하는 개념을 의미하고, &quot;blay&quot;는 요청 시 최종 프레젠테이션을 위해 데이터를 처리하는 개념(즉, 제때에)을 의미합니다.

**클러스터링 및 로드 밸런싱**  - 프로덕션 환경의 가용성을 높이고 성능을 향상시키기 위해 여러 작성자 및/또는 게시 인스턴스를 여러 사용자 그룹에 사용할 수 있게 하거나 Dispatcher 구성 뒤에서 로드 밸런싱을 통해 클러스터로 결합하는 것이 일반적입니다.

또한 컨텐츠 저장소의 여러 인스턴스를 결합하여 *고가용성* JCR 솔루션을 만들 수 있으며, 이를 AEM 솔루션과 통합하여 하드웨어 및 소프트웨어 장애에 대한 보호를 극대화할 수 있습니다. 자세한 내용은 [권장 배포](/help/sites-deploying/recommended-deploys.md#oak-cluster-with-mongomk-failover-for-high-availability-in-a-single-datacenter)를 참조하십시오.

**구성 요소**  - AEM에서 구성 요소는 개체 유형으로, 일반적으로 사이드 킥에서 구성 요소를 드래그하여 놓아 인스턴스를 만들 수 있습니다. 예를 들어 AEM과 함께 제공되는 기본 구성 요소에는 런타임 시 사이드 킥에서 모두 사용할 수 있는 텍스트, 제목, 태그 클라우드, 캐러셀, 이미지 및 목록 구성 요소가 포함되어 있습니다.

**컨텐츠 파인더**  - 작성 모드에서 컨텐츠 파인더는 페이지의 왼쪽에 있는 특수 패널(프레임)으로, 위쪽에서 선택하는 탭에 따라 컨텐츠 파인더에서 드래그하여 작업 중인 페이지로 놓을 수 있는 이미지, 문서, Flash 자산, 페이지, 단락 또는 저장소 리소스의 목록을 표시합니다.

**디지털 자산**  - AEM에서 디지털 자산은 (일반적으로) 이미지와 리치 미디어 파일입니다. 자세한 내용은 DAM에서 디지털 자산 작업을 참조하십시오.

**디스패처**  - 디스패처는 캐싱 및 로드 밸런싱 도구일 뿐만 아니라 특정 보안 조치를 제공합니다.

**ExtJS 위젯**  - AEM의 대부분의 사용자 인터페이스 요소는 JavaScript로 작성된 타사 위젯 라이브러리인 ExtJS를 사용합니다. ExtJS는 고성능의 사용자 정의 가능한 UI 위젯과 잘 설계된 확장 가능한 구성 요소 모델을 제공합니다.

**JCR, Java 컨텐츠 저장소**  - JSR-283(Java Content Repository) 사양은 추상 데이터 모델과 응용 프로그램 프로그래밍 인터페이스를 모두 제공하여 파일 시스템 및 객체 데이터베이스의 기능을 결합한 대량 확장 가능한 NoSQL 데이터 저장소를 구현할 수 있습니다. JSR-283을 완전히 세부적으로 이해할 필요는 없지만 JCR의 기본 기능과 이를 기초로 하는 데이터 모델을 숙지하는 데 시간이 걸릴 수 있습니다. JCR은 AEM의 &quot;모든 것이 컨텐츠&quot; 철학이 될 수 있는 이유입니다.

본질적으로 JCR은 노드가 다른 노드에서 상속할 수 있고 모든 컨텐츠가 *values* 속성으로 저장되는 노드 및 속성의 시스템입니다. JCR은 일반적인 상속 외에도 여러 상속을 모델링할 수 있는 &quot;mixin&quot; 노드의 개념을 허용합니다.

JCR은 사전 정의된 노드 유형 및 속성 유형을 다수 보유하고 있지만 일반적으로 입력 시스템은 매우 유연하며, (실제로) JCR의 장점 중 하나는 구조화된 컨텐츠와 구조화되지 않은 컨텐츠를 같은 방식으로 저장/관리할 수 있다는 것입니다. 즉, JCR은 고도로 구조화된 데이터를 수용할 수 있지만 스키마 제약 없이 임의의 동적 데이터 구조를 수용할 수도 있습니다.

JCR의 Java API에 대한 JavaDoc는 [여기](http://jackrabbit.apache.org/jcr/jcr-api.html)입니다.

JavaDoc 또는 JCR 사양을 읽기 전에 Adobe Experience Services에서 구현한 JCR의 [이 수준 높은 설명](/help/sites-developing/the-basics.md#java-content-repository)을 확인하시기 바랍니다.

**MSM(Multi-Site Manager)** - AEM의 MSM 기능을 사용하면 다국어 및 다국적 컨텐츠를 처리할 수 있으므로 로컬라이즈된 컨텐츠와 중앙 브랜딩의 균형을 맞출 수 있습니다.

**OSGi** - OSGi는 AEM의 모듈화된 Java 개발을 위한 기반을 제공하는 서비스 기반 런타임 기술입니다. 코드 리소스(번들로 알려져 있음)에 대한 높은 동적(안전한) 클래스 로딩 및 실행 환경을 제공할 뿐만 아니라 번들로 밝혀진 다양한 서비스의 가시성과 라이프사이클을 완벽하게 제어하는 프레임워크입니다. 서비스 레지스트리에서는 라이프사이클 동적(및 버전 요구 사항)을 고려하는 번들에 대한 협력 모델을 제공합니다. OSGi는 애플리케이션 서버가 해결하려고 했던 많은 문제를 해결하지만, 크기가 작고 동적인 방식으로 해결하므로, 예를 들어, 핫-배포 서비스를 가능하게 합니다(서버를 다시 시작하지 않고 새로운 코드를 즉시 사용 가능하게 만들기).

**Parsys, Paragraph System**  - 단락 시스템(parsys)은 작성자가 여러 유형의 구성 요소를 페이지에 추가하고 다른 단락 구성 요소를 포함할 수 있도록 해주는 복합 구성 요소입니다. 각 단락 유형은 구성 요소로 표현됩니다. 단락 시스템 자체도 하나의 구성 요소이며, 다른 모든 단락 구성 요소를 포함합니다.

**마이크로커널**  - 저장소의 모든 작업 영역은 데이터를 특정 마이크로커널(데이터 읽기 및 쓰기를 관리하는 클래스)을 통해 저장하도록 별도로 구성할 수 있습니다. 마찬가지로 저장소 전체 버전 저장소는 특정 마이크로커널을 사용하도록 독립적으로 구성할 수도 있습니다. 다양한 마이크로커널이 제공되므로 다양한 파일 포맷 또는 관계형 데이터베이스에 데이터를 저장할 수 있습니다. (예를 들어 MongoDB, DB2 또는 Oracle에 대한 지속성 관리자가 있습니다) AEM에 대한 기본 마이크로커널은 TarMK입니다(아래 참조).

**게시 인스턴스**  - 보안, 거버넌스 및 기타 이유로 제작 사이트는 일반적으로 AEM 인스턴스를 작성자 및 게시 인스턴스로 나눕니다. 배포 아키텍처(작성자/게시 인스턴스 포함)에 대한 자세한 내용은 AEM 인스턴스에 대한 설명서를 참조하십시오.

**Quickstart**  - 다른 많은 프로그램과는 달리 단일 &quot;Quickstart&quot; 자동 압축 해제 JAR 파일을 사용하여 AEM을 설치합니다. JAR 파일을 처음으로 두 번 클릭하면 필요한 모든 것이 자동으로 설치됩니다. 빠른 시작 JAR에는 CRX 저장소(관리 시설 포함), 가상 저장소 서비스, 색인 및 검색 서비스, 워크플로우 서비스, 보안 및 웹 서버에 필요한 모든 파일과 CQSE(Servlet Engine) 및 모든 AEM 서비스가 포함됩니다. 설치할 다른 파일이 없습니다.빠른 시작 기능은 자체 포함되어 있습니다.

Quickstart를 처음 시작하면 백그라운드에서 JCR과 호환되는 전체 저장소가 생성되므로 몇 분 정도 걸릴 수 있습니다. 이 초기 시작 후 저장소 인프라가 이미 정리되었기 때문에 이후 신생 기업이 훨씬 더 빨라졌습니다.

많은 시작 옵션(예: 활성 포트 번호 및 문제의 AEM 인스턴스가 게시 인스턴스와 작성자 인스턴스여야 하는지 여부)등)을 제어하려면 Quickstart 파일의 이름을 적절하게 변경하여 제어할 수 있습니다. 이와 같은 옵션 목록을 보려면 명령줄에서 &quot;-help&quot;를 사용하여 JAR를 실행합니다.

```shell
java -jar <quickstartfilename>.jar -help
```

**복제 에이전트**  - Replication Agent는 작성자에서 게시 환경으로 컨텐츠를 게시(활성화)하는 데 사용되는 메커니즘으로 AEM의 중앙 역할을 합니다.디스패처 캐시에서 컨텐트 제거;사용자가 생성한 컨텐츠(예: 양식 입력)를 게시 환경에서 작성 환경으로 반환합니다.

**Scaffolding** - Scaffolding을 사용하면 페이지에 사용할 구조를 반영하는 필드가 포함된 양식(Scaffold)을 만든 다음 이 양식을 사용하여 이 구조를 기반으로 페이지를 쉽게 만들 수 있습니다.

**세분화**  - 사이트 방문자가 사이트에 들어올 때 서로 다른 관심사와 목표를 갖습니다. 방문자의 목표를 이해하고 고객의 기대를 충족할 수 있는 것은 온라인 마케팅을 위한 중요한 성공 필수 요소입니다. 세그멘테이션은 방문자의 세부 사항을 분석 및 특정하여 이를 실현하는 데 도움이 됩니다.

**사이드 킥은**  편집 가능한 페이지에 표시되는 팔레트와 같은 부동 창으로, 새로운 구성 요소를 드래그할 수 있으며 페이지에 적용되는 작업을 실행할 수 있습니다.

**Site Catalyst** - SiteCatalyst을 통해 마케터는 다양한 마케팅 채널에서 모든 온라인 이니셔티브의 통합 데이터를 측정, 분석 및 최적화할 수 있습니다. Adobe SiteCatalyst을 사용하여 AEM 웹 사이트의 데이터를 분석할 수 있습니다.

**Tar Storage(TarMK)**  - TarMK는 AEM의 기본 지속성 시스템입니다. AEM은 다른 지속성 시스템(예: MongoDB)을 사용하도록 구성할 수 있지만 TarMK는 일반적인 JCR 사용 사례(매우 빠른 경우)에 대해 성능이 최적화되어 업계 표준 데이터 형식을 사용하고 빠르고 쉽게 백업할 수 있다는 장점이 있습니다.

**템플릿**  - AEM에서 템플릿은 페이지의 특정 유형을 지정합니다. 페이지의 구조를 정의합니다(일반적으로 축소판 이미지 및 다양한 속성을 지정하기도 함). 예를 들어 제품 페이지, 사이트 맵 및 연락처 정보에 서로 다른 템플릿을 사용할 수 있습니다.

**워크플로우**  - AEM 워크플로우 시스템을 사용하면 페이지 또는 자산을 포함하는 자동화된 프로세스를 만들 수 있습니다.
