---
title: AEM에 기여
seo-title: Contributing to AEM
description: AEM은 대규모 오픈 소스 프로젝트에서 일반적으로 사용되는 검증된 방법론에 따라 개발되었습니다
seo-description: AEM is developed following proven methodologies commonly practiced in large open source projects
uuid: ffef60ae-8a9a-4c4b-8cbd-3cd72792a42e
contentOwner: Guillaume Carlino
products: SG_EXPERIENCEMANAGER/6.5/SITES
topic-tags: introduction
content-type: reference
discoiquuid: f52402df-f6dc-4c62-82bc-cbce489b2b74
exl-id: 43fb4fa3-269a-4635-b055-4b7d787da21f
source-git-commit: 9d142ce9e25e048512440310beb05d762468f6a2
workflow-type: tm+mt
source-wordcount: '2709'
ht-degree: 1%

---

# AEM에 기여{#contributing-to-aem}

## 개발 방법론 {#development-methodology}

AEM은 대규모 오픈 소스 프로젝트에서 일반적으로 사용되는 검증된 방법론에 따라 개발되었습니다. AEM 기술 스택의 많은 핵심 요소는 실제로 Apache Software Foundation에 기여한 Sling 및 Jackrabbit과 같은 활성 오픈 소스 프로젝트로 유지 관리됩니다. AEM에 나와 있는 이 기술의 주요 관점은 개발팀과의 직접적인 상호 작용을 위해 사용 가능한 메일링 목록과 온라인 포럼을 사용하는 것이 좋다는 것입니다.

AEM의 구성 요소에 기여하고 있는 경우, 공개 소스 프로젝트에 기여할 때와 같이 AEM에 익숙해지도록 하고, 그러한 프로젝트에 기여하려는 경우처럼 기존 핵심 팀과 통신해야 합니다.

## 필수 경험 {#required-experience}

HTTP(HyperText Transfer Protocol)는 Adobe가 수행하는 모든 작업의 중심입니다. 따라서 AEM에 기여하기 전에 스레드 풀링을 사용하여 멀티스레드 HTTP 서버의 자체 Java 구현을 작성할 수 있는 범위 내에서 HTTP를 깊이 이해해야 합니다. HTTP/1.1 keep-alive 동작에 대해서도 알고 있어야 하며 JavaScript와의 서버/클라이언트측 상호 작용, 특히 AJAX으로 표시되는 비동기 스타일의 상호 작용에 대한 심도 있는 지식이 있어야 합니다.

페이지 동적 및 대화형 컨텐츠는 WM 환경의 핵심 요소이므로, 문서 객체 모델과 이벤트에 대한 프로그래밍 방식 조작에 대한 잠재력을 상당히 깊이 알고 있어야 합니다. 예를 들어, 여러 브라우저 문서(예: iframe 사용)에서 실시간 DOM 조작 및 드래그 앤 드롭 동작에 대한 지식이 있어야 합니다.

이때 가장 높은 수준에서 다음 사항에 대한 분명한 이해를 가져야 합니다.

* a [HTTP/1.1 프로토콜](https://www.ietf.org/rfc/rfc2616.txt)
* HTML(바람직함) [HTML5](https://dev.w3.org/html5/spec/Overview.html))
* 계단식 스타일 시트
* XML(Extensible Markup Language)
* 비동기 JavaScript 및 XML(AJAX) 디자인 패턴
* JavaScript 개체 표기법(JSON)
* 문서 객체 모델
* 상태 저장 및 상태 비저장 상호 작용
* [Uniform Resource Identifiers](https://www.ietf.org/rfc/rfc2396.txt)
* 브라우저 쿠키
* 및 기타 최신 웹 개발 개념

Adobe Experience Manager의 기술 스택은 [Apache Felix](https://felix.apache.org/) OSGI 컨테이너 및 [Apache Sling](https://sling.apache.org/site/index.html) 웹 프레임워크 및 Java Content Repository 포함([JCR](https://www.adobe.io/experience-manager/reference-materials/spec/jcr/2.0/index.html)) [Apache Jackrabbit](https://jackrabbit.apache.org/jcr-api.html). 기여하려는 영역에서 사용되는 다른 오픈 소스 구성 요소(예: Apache Lucene)는 물론 이러한 개별 프로젝트에 대해 숙지해야 합니다.

## 부족 지식 {#tribal-knowledge}

어떤 개념과 지도 원칙은 이전 날의 문화에서 깊이 배어 있습니다. 이 섹션은 사용자가 알아야 할 &quot;깊이 있는 DNA 포함&quot; 문제들을 나열합니다.

### 모든 것이 콘텐츠입니다. {#everything-is-content}

컨텐츠에는 웹 애플리케이션이 지속되는 모든 데이터가 포함됩니다. 모든 종류의 프로그램 코드, 라이브러리, 스크립트, 템플릿, HTML, CSS, 이미지 및 아티팩트는 컨텐츠 리포지토리에 유지되며 패키지 관리자 및 패키지 공유를 통해 패키지 형태로 가져오거나 내보냅니다.

### 데이비드 모델 {#david-s-model}

Java Content Repository에서 컨텐츠를 모델링하는 방법은 관계형 환경에서 데이터 모델링을 위해 소프트웨어 업계에서 일반적으로 사용되는 방식과 완전히 다른 사고방식을 요구합니다. JCR 방식에서 컨텐츠 관리를 새로 수행하는 모든 사용자에게 필수적인 읽기 기능은 다음과 같습니다 [데이비드 모델: 컨텐츠 모델링을 위한 안내서](https://wiki.apache.org/jackrabbit/DavidsModel).

### RESTfulness {#restfulness}

REST 접근 방식은 우리가 하는 일에 깊이 스며들어 있습니다. 즉, 다른 어떤 것 중에서, 상태 저장 상호 작용을 피하고 URI가 컨텐츠 및 서비스에 대한 최종 주소임을 기억합니다.

REST(Presentative State Transfer)는 World Wide Web을 기반으로 하는 소프트웨어 아키텍처 스타일을 나타냅니다. 웹을 작동시키는 주요 요소에 대해 설명하고 웹 기반 소프트웨어를 설계하는 방법에 대한 일련의 원칙을 제공합니다. 웹에서 사용할 API를 디자인할 때 이러한 &quot;우수 사례&quot;를 준수하는 것이 적절합니다.

REST는 우리가 하는 대부분의 작업 이면에 대한 안내 철학을 제공하므로 RESTful 디자인의 장점에 대해 잘 통달하게 되는 것이 중요하다고 생각해야 합니다. 좋은 출발점은 [로이 수핑의 논문](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm).

### Sling 요청 해상도 {#sling-request-resolution}

AEM에 대해 이해하는 주요 측면은 들어오는 요청이 컨텐츠 및 애플리케이션 동작과 어떻게 관련되는지, 컨텐츠가 컨텐츠 저장소에서 구조화되고 AEM이 요청을 처리할 애플리케이션 로직을 찾는 방식입니다. Apache에 대해 알아보기 [Sling URL 분해](https://sling.apache.org/site/url-decomposition.html) 그리고 REST 아키텍처 스타일 및 상태를 저장하지 않고 캐시할 수 있으며 계층화된 시스템 제약 조건을 적용하는 방법입니다.

Apache Sling의 요청 해상도에 대해 이해하기 위한 주요 측면은 요청이 주로 컨텐츠 저장소의 특정 리소스에 매핑되는 방법, 이러한 컨텐츠 객체의 속성과 함께 요청의 추가 속성이 컨텐츠를 렌더링하기 위해 호출되는 애플리케이션 코드 및 /apps의 코드가 /libs에서 코드를 재지정하는 방법을 결정하는 것입니다.

### Quickstart {#quickstart}

3단계 없음: 설치하고 실행하려면 Quickstart JAR 파일을 두 번 클릭하여 다운로드하면 됩니다. 3단계는 없습니다. 추가 옵션 기능은 패키지 공유에서 해당 패키지를 설치하는 것 외에는 필요하지 않습니다.

작은 빠른 시작 크기: Quickstart JAR 파일의 크기를 최소 수준으로 유지합니다. 라이브러리를 지능적이고 최적화된 상태로 사용하여 패키지 공유로 옵션 기능을 이동할 수 있습니다.

빠른 시작 시간: 시작 시간에 영향을 줄 수 있는 변경 작업을 수행하는 경우 더 이상 짧지 않게 됩니다.

### 린 및 평균 {#lean-and-mean}

우리는 가볍고, 작고, 빠르고, 우아한 코드와 프로젝트를 선호합니다. &quot;충분히 좋다&quot;는 것은 충분하지 않다.

코드 재사용: Adobe의 OSGi 기반 제품 아키텍처와 &quot;모든 것이 컨텐츠입니다&quot; 철학은 코드와 객체를 재사용할 수 있는 매우 좋은 기회를 가지고 있음을 의미합니다. 우리는 가능한 한 그 사실을 활용하기 위해 무뚝뚝한 성격을 유지하려고 노력한다.

느슨한 결합: 우리는 느슨하게 결합된 상호작용과 &quot;원치 않는 친밀감&quot;을 좋아한다. 느슨한 결합을 통해 더 많은 코드를 다시 사용할 수 있습니다.

### 데모 중단 안 함 {#don-t-break-the-demo}

데모 시 가장 많이 표시되는 데모 스크립트 및 제품 기능에 익숙해지십시오. 최소한 &quot;데모 스크립트&quot; 기능을 중단해서는 안 됩니다. 핵심 제품은 개발 중에도 항상 데모 준비가 되어 있어야 합니다.

### 신뢰성 설계 {#design-for-reliability}

Adobe는 예를 들어 단일 DOM 요소에 문제가 있는 경우 전체 페이지가 렌더링되지 않도록 fail-soft로 디자인 및 코드 기능을 설계하려고 합니다. 즉, 치명적이고 치명적인 것들을 만들어라. 다른 모든 것을 생존할 수 있게 만듭니다. 제품을 &quot;용서하라&quot;로 만듭니다.

### 비정상은 새로운 표준입니다 {#abnormal-is-the-new-normal}

종료 후크에 의존하지 말고 시작 시 정리를 확인합니다. 비정상적인 종료는 정상적인 종결입니다.

`shutdown == kill -9 == power outage`

### 탄성 클러스터링 준비 {#be-ready-for-elastic-clustering}

항상 탄력적인 클러스터링을 위해 준비하십시오. 항상 클러스터링이 있다고 가정하십시오. 일반적으로 컨텐츠 리포지토리에 있는 모든 것을 준수하는 것은 클러스터링 지원을 통해 구축됩니다.

### 이전 버전과의 호환성을 위한 디자인 {#design-for-backward-compatibility}

어떤 작업도 고객의 이전 코드를 손상해서는 안 됩니다. 전용 `/libs` 를 입력하여 업그레이드 중에 업데이트할 수 있는 제품 코드를 포함합니다. 다음 `/apps` 저장소의 섹션은 프로젝트 코드이고, `/etc` 섹션에는 보존해야 하는 사용자 지정 구성이 포함되어 있습니다. 일반적으로 을 덮어쓰지 마십시오 `/apps`, `/content` 및 `/home`. 업그레이드 후 이전 프로젝트 코드, 구성 및 컨텐츠는 업그레이드 전과 마찬가지로 계속 작동해야 합니다.

이전 버전과의 호환성을 위해 설계하면 업그레이드 경험이 초기 설치의 간편성과 일치할 수 있습니다. AEM을 중지하고, Quickstart JAR 파일을 교체하면 AEM을 다시 시작하면 충분합니다. 설치 기반이 급격히 증가함에 따라 업그레이드 효율성이 점점 더 크게 향상됩니다.

기존 API는 최신 API에서 더 이상 사용되지 않음으로 표시되어야 하지만 더 나은 기능이 이를 대체하므로 이전 5.x 릴리스에서 공개되었던 모든 API는 사용자 지정 애플리케이션 코드에서 사용 중일 수 있으므로 계속 작동해야 합니다. 이러한 API는 제거할 필요가 없습니다.

컨텐츠 구조 및 사용자 경험의 일반적인 일관성과 관련하여 이전 버전과의 호환성을 염두에 두어야 합니다.

## 핵심 개념 {#core-concepts}

**작성자 인스턴스** - 일반적으로 보안, 거버넌스 및 기타 이유로 프로덕션 사이트는 AEM 인스턴스를 작성자 및 게시 인스턴스로 분할합니다. 배포 아키텍처(작성자/게시 인스턴스 포함)에 대한 자세한 내용은 AEM 인스턴스에 대한 설명서를 참조하십시오.

**캐싱, 튀김 및 굽기** 일반적으로 굽기와 튀김이라는 개념은 서로 다른 웹 컨텐츠 관리 시스템 간의 중요한 차이점입니다. CMS 용어로 베이킹(bing)은 정적 파일을 게시 시점에 커밋하는 개념이고, 프라이는 요청 시 최종 프레젠테이션을 위해 데이터를 처리하는 개념(즉, 정시)을 의미한다.

**클러스터링 및 로드 밸런싱** - 가용성을 높이고 프로덕션 환경의 성능을 향상시키기 위해 여러 사용자 그룹에서 사용할 수 있도록 하거나 Dispatcher 구성 뒤에서 로드 밸런싱하여 여러 작성자 및/또는 게시 인스턴스(클러스터로)를 결합하는 것이 일반적입니다.

컨텐츠 리포지토리의 여러 인스턴스를 결합하여 *고가용성* JCR 솔루션 - AEM 솔루션과 통합하여 하드웨어 및 소프트웨어 장애에 대한 보호를 극대화할 수 있습니다. 자세한 내용은 [권장 배포](/help/sites-deploying/recommended-deploys.md#oak-cluster-with-mongomk-failover-for-high-availability-in-a-single-datacenter) 추가 정보.

**구성 요소** - AEM에서 구성 요소 는 객체 유형이며, 일반적으로 사이드 킥과 같이 인스턴스를 드래그 드롭하여 생성할 수 있습니다. 따라서 AEM과 함께 제공되는 기본 구성 요소에는 텍스트, 제목, 태그 클라우드, 회전 메뉴, 이미지 및 목록 구성 요소가 모두 런타임 시 사이드 킥에서 사용할 수 있습니다.

**컨텐츠 파인더** - 작성 모드에서 컨텐츠 파인더는 페이지의 왼쪽에 있는 특수 패널(프레임)으로, 맨 위에서 선택한 탭에 따라 컨텐츠 파인더에서 작업 중인 페이지(오른쪽)로 끌어다 놓을 수 있는 이미지, 문서, Flash 자산, 페이지, 단락 또는 저장소 리소스 목록을 표시합니다.

**디지털 자산** - AEM에서 디지털 자산은 (일반적으로) 이미지와 리치 미디어 파일입니다. 자세한 내용은 DAM에서 디지털 자산 작업 을 참조하십시오.

**Dispatcher** - Dispatcher는 특정 보안 보호 기능을 제공할 뿐만 아니라 캐싱 및 로드 밸런싱 도구입니다.

**ExtJS 위젯** - AEM의 대부분의 사용자 인터페이스 요소는 JavaScript로 작성된 타사 위젯 라이브러리인 ExtJS를 사용합니다. ExtJS는 고성능, 사용자 정의 가능한 UI 위젯과 잘 디자인되고 확장 가능한 구성 요소 모델을 제공합니다.

**JCR, Java Content Repository** - JSR-283(Java Content Repository Specification)은 추상 데이터 모델과 파일 시스템의 기능과 객체 데이터베이스의 기능을 결합하는 대량 확장 가능한 NoSQL 데이터 저장소를 구현하기 위한 응용 프로그램 프로그래밍 인터페이스를 모두 제공합니다. JSR-283을 완전히 세부적으로 이해할 필요는 없지만 JCR이 AEM의 &quot;모든 것이 컨텐츠&quot; 철학을 가능하게 하는 요소이므로 JCR의 기본 기능과 그 기반이 되는 데이터 모델을 숙지하는 데 시간을 기울여야 합니다.

기본적으로 JCR은 노드가 다른 노드에서 상속될 수 있고 모든 컨텐츠가 속성으로 저장되는 노드 및 속성 시스템입니다 *값*. JCR에서는 일반 상속 외에도 &quot;mixin&quot; 노드의 개념을 허용하여 여러 상속을 모델링할 수 있습니다.

JCR에는 사전 정의된 노드 유형 및 속성 유형이 많지만, 일반적으로 유형 지정 시스템은 매우 유연하며, JCR의 장점 중 하나는 구조화된 컨텐츠와 구조화되지 않은 컨텐츠를 동일한 방식으로 저장/관리할 수 있다는 것입니다. 즉, JCR은 고도로 구조화된 데이터를 수용할 수 있지만 스키마 제약 없이 임의의 동적 데이터 구조를 수용할 수도 있습니다.

JCR의 Java API에 대한 JavaDoc는 [여기](http://jackrabbit.apache.org/jcr/jcr-api.html).

JavaDoc나 JCR 사양 자체를 읽기 전에 [이 높은 수준의 설명](/help/sites-developing/the-basics.md#java-content-repository) Adobe Experience Services에서 구현한 JCR의 수입니다.

**다중 사이트 관리자(MSM)** - AEM의 MSM 기능은 고객이 다국어 및 다국적 컨텐츠를 처리하여 현지화된 콘텐츠와 중앙 브랜딩의 균형을 맞출 수 있도록 도와줍니다.

**OSGi** - OSGi는 AEM에서 모듈화된 Java 개발의 기초를 제공하는 서비스 기반 런타임 기술입니다. 이 프레임워크는 코드 리소스(번들로 알려져 있음)에 대한 높은 동적(및 보안) 클래스 로드 및 실행 환경을 제공할 뿐만 아니라 번들에 의해 노출된 다양한 서비스의 가시성과 라이프사이클을 완벽하게 제어하는 프레임워크입니다. 서비스 레지스트리에서는 라이프사이클 다이내믹(및 버전 요구 사항)을 고려하는 번들에 대한 협력 모델을 제공합니다. OSGi는 애플리케이션 서버가 해결하고자 했던 많은 문제를 해결했지만, 가볍고 동적인 방식으로 해결되므로, 예를 들어 핫 배포 서비스(서버를 다시 시작하지 않고 새 코드를 즉시 사용 가능)를 가능하게 합니다.

**Parsys, 단락 시스템** - 단락 시스템(parsys)은 작성자가 페이지에 여러 유형의 구성 요소를 추가할 수 있는 복합 구성 요소로서, 다른 단락 구성 요소를 포함합니다. 각 단락 유형은 구성 요소로 표현됩니다. 단락 시스템 자체도 하나의 구성 요소이며, 다른 모든 단락 구성 요소를 포함합니다.

**마이크로커널** - 저장소의 모든 작업 영역은 특정 마이크로커널(데이터의 읽기 및 쓰기를 관리하는 클래스)을 통해 데이터를 저장하도록 개별적으로 구성할 수 있습니다. 마찬가지로, 특정 마이크로커널을 사용하도록 별도로 저장소 전체 버전 저장소를 구성할 수 있다. 다양한 파일 형식 또는 관계형 데이터베이스에 데이터를 저장할 수 있는 다양한 마이크로케널을 사용할 수 있습니다. (예를 들어 MongoDB, DB2 또는 Oracle에 대한 지속성 관리자가 있습니다) AEM의 기본 마이크로커널은 TarMK입니다(아래 참조).

**게시 인스턴스** - 보안, 거버넌스 및 기타 이유로 인해 프로덕션 사이트는 일반적으로 AEM 인스턴스를 작성자 및 게시 인스턴스로 나눕니다. 배포 아키텍처(작성자/게시 인스턴스 포함)에 대한 자세한 내용은 AEM 인스턴스에 대한 설명서를 참조하십시오.

**빠른 시작** - 다른 많은 프로그램과 달리 하나의 &quot;Quickstart&quot; 자동 추출 JAR 파일을 사용하여 AEM을 설치합니다. 처음으로 JAR 파일을 두 번 클릭하면 필요한 모든 항목이 자동으로 설치됩니다. 빠른 시작 JAR에는 CRX 저장소(관리 시설 포함), 가상 저장소 서비스, 인덱스 및 검색 서비스, 워크플로우 서비스, 보안 및 웹 서버에 필요한 모든 파일과 CQ 서블릿 엔진(CQSE) 및 모든 AEM 서비스가 포함됩니다. 설치할 다른 파일이 없습니다. quickstart는 자체 포함되어 있습니다.

Quickstart를 처음 시작하면 배경에 전체 JCR 호환 리포지토리가 생성되며 몇 분이 걸릴 수 있습니다. 이 초기 시작 후 저장소 인프라가 이미 정리되어 있기 때문에 이후 스타트업이 훨씬 더 빠릅니다.

많은 시작 옵션(예: 활성 포트 번호 및 해당 AEM 인스턴스가 게시 인스턴스와 작성자 인스턴스여야 하는지 여부) 보다 많은 )은 Quickstart 파일의 이름을 적절하게 변경하여 제어할 수 있습니다. 이와 같은 옵션 목록을 보려면 명령줄에서 &quot;-help&quot;를 사용하여 JAR를 실행하십시오.

```shell
java -jar <quickstartfilename>.jar -help
```

**복제 에이전트** - 작성자 환경에서 게시 환경에 컨텐츠를 게시(활성화)하는 데 사용되는 메커니즘으로 복제 에이전트가 AEM의 중심입니다. 디스패처 캐시에서 콘텐츠를 플러시합니다. 게시 환경에서 작성 환경으로 사용자가 생성한 컨텐츠(예: 양식 입력)를 반환합니다.

**스캐폴딩** - 스캐폴딩을 사용하면 페이지에 적용할 구조를 반영하는 필드가 포함된 양식(스캐폴드)을 만든 다음 이 양식을 사용하여 이 구조를 기반으로 페이지를 쉽게 만들 수 있습니다.

**세그먼테이션** - 사이트 방문자가 사이트를 방문할 때 사이트 방문자의 관심사와 목표가 다릅니다. 온라인 마케팅을 위해 방문자의 목표를 이해하고 기대에 부응하는 것은 중요한 성공 전제 조건입니다. 세그멘테이션은 방문자의 세부 사항을 분석하고 특성을 지정하여 이를 달성하는 데 도움이 됩니다.

**사이드킥입니다** - 사이드킥은 편집 가능한 페이지에 표시되는 팔레트와 같은 부동 창으로, 새로운 구성 요소를 드래그할 수 있고 페이지에 적용되는 작업을 실행할 수 있습니다.

**Site Catalyst** - SiteCatalyst은 여러 마케팅 채널에서 모든 온라인 이니셔티브의 통합 데이터를 측정, 분석 및 최적화하는 하나의 지점을 마케터에게 제공합니다. Adobe SiteCatalyst을 사용하여 AEM 웹 사이트에서 데이터를 분석할 수 있습니다.

**Tar 저장소(TarMK)** - TarMK는 AEM의 기본 지속성 시스템입니다. AEM은 다른 지속성 시스템(예: MongoDB)을 사용하도록 구성할 수 있지만, TarMK는 일반적인 JCR 사용 사례에 맞게 성능이 최적화되어 매우 빠르며, 업계 표준 데이터 형식을 사용하며 빠르고 쉽게 백업할 수 있는 이점이 있습니다.

**템플릿** - AEM에서 템플릿은 특정 유형의 페이지를 지정합니다. 페이지의 구조를 정의합니다(하지만 일반적으로 축소판 이미지와 다양한 속성을 지정할 수도 있음). 예를 들어 제품 페이지, 사이트 맵 및 연락처 정보에 서로 다른 템플릿을 사용할 수 있습니다.

**워크플로우** - AEM 워크플로우 시스템을 통해 페이지 또는 자산과 관련된 자동화된 프로세스를 만들 수 있습니다.
