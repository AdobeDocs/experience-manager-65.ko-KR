---
title: 사용자, 그룹 및 액세스 권한 관리
description: Adobe Experience Manager의 사용자, 그룹 및 액세스 권한 관리에 대해 알아봅니다.
products: SG_EXPERIENCEMANAGER/6.5/SITES
topic-tags: Security
content-type: reference
docset: aem65
exl-id: 5808b8f9-9b37-4970-b5c1-4d33404d3a8b
feature: Security
solution: Experience Manager, Experience Manager Sites
role: Admin
source-git-commit: 48d12388d4707e61117116ca7eb533cea8c7ef34
workflow-type: tm+mt
source-wordcount: '3073'
ht-degree: 0%

---

# 사용자, 그룹 및 액세스 권한 관리{#user-group-and-access-rights-administration}

CRX 저장소에 대한 액세스 활성화에는 다음과 같은 몇 가지 주제가 포함됩니다.

* [액세스 권한](#how-access-rights-are-evaluated) - 액세스 권한 정의 및 평가 방법에 대한 개념
* [사용자 관리](#user-administration) - 액세스에 사용되는 개별 계정 관리
* [그룹 관리](#group-administration) - 그룹을 구성하여 사용자 관리 간소화
* [액세스 권한 관리](#access-right-management) - 이러한 사용자와 그룹이 리소스에 액세스하는 방법을 제어하는 정책을 정의합니다.

기본 요소는 다음과 같습니다.

**사용자 계정** - CRX은 사용자 계정에 보관된 세부 정보에 따라 사용자(해당 사용자 또는 다른 애플리케이션)를 식별하고 확인하여 액세스를 인증합니다.

CRX에서 모든 사용자 계정은 작업 영역의 노드입니다. CRX 사용자 계정에는 다음 속성이 있습니다.

* CRX 사용자 1명을 나타냅니다.
* 사용자 이름과 암호가 들어 있습니다.
* 해당 작업 영역에 적용할 수 있습니다.
* 하위 사용자를 가질 수 없습니다. 계층 액세스 권한의 경우 그룹을 사용해야 합니다.

* 사용자 계정에 대한 액세스 권한을 지정할 수 있습니다.

  Adobe 그러나 관리를 단순화하기 위해서는 대부분의 경우 그룹 계정에 액세스 권한을 할당하는 것이 좋습니다. 각 개별 사용자에 대한 액세스 권한을 할당하면 관리가 신속하게 어려워집니다(인스턴스가 한 개 또는 두 개만 있는 경우 특정 시스템 사용자는 예외입니다).

**그룹 계정** - 그룹 계정은 사용자 및/또는 다른 그룹의 컬렉션입니다. 그룹에 할당된 액세스 권한의 변경 사항이 해당 그룹의 모든 사용자에게 자동으로 적용되므로 관리를 단순화하는 데 사용됩니다. 사용자는 어떤 그룹에도 속할 필요는 없지만 여러 그룹에 속하는 경우가 많습니다.

CRX에서 그룹은 다음 속성을 갖습니다.

* 공통 액세스 권한이 있는 사용자 그룹을 나타냅니다. (예: 작성자 또는 개발자)
* 해당 작업 영역에 적용할 수 있습니다.
* 구성원이 있을 수 있으며, 이는 개별 사용자 또는 다른 그룹일 수 있습니다.
* 멤버 관계를 통해 계층적인 그룹화를 수행할 수 있습니다. 저장소의 다른 그룹 바로 아래에 그룹을 배치할 수 없습니다.
* 모든 그룹 멤버에 대한 액세스 권한을 정의할 수 있습니다.

**액세스 권한** - CRX은 액세스 권한을 사용하여 저장소의 특정 영역에 대한 액세스를 제어합니다.

이 작업은 저장소의 리소스(노드 또는 경로)에 대한 액세스를 허용 또는 거부하는 권한을 할당함으로써 수행됩니다. 다양한 권한을 지정할 수 있으므로 현재 요청에 적용할 수 있는 조합을 결정하기 위해 권한을 평가해야 합니다.

CRX을 사용하면 사용자 및 그룹 계정 모두에 대한 액세스 권한을 구성할 수 있습니다. 그런 다음 동일한 기본 평가 원칙이 양쪽 모두에 적용됩니다.

## 액세스 권한 평가 방법 {#how-access-rights-are-evaluated}

>[!NOTE]
>
>CRX은 JSR-283[&#128279;](https://developer.adobe.com/experience-manager/reference-materials/spec/jcr/2.0/16_Access_Control_Management.html)에서 정의한 액세스 제어를 구현합니다.
>
>CRX 저장소의 표준 설치는 리소스 기반 액세스 제어 목록을 사용하도록 구성됩니다. 이는 JSR-283 액세스 제어의 한 가지 가능한 구현과 Jackrabbit과 함께 제공되는 구현 중 하나입니다.

### 주체 및 주체 {#subjects-and-principals}

CRX은 액세스 권한을 평가할 때 두 가지 주요 개념을 사용합니다.

* **principal**&#x200B;은(는) 액세스 권한을 가진 엔터티입니다. 주도자는 다음과 같습니다.

   * 사용자 계정
   * 그룹 계정

     사용자 계정이 하나 이상의 그룹에 속하는 경우 해당 그룹 주도자 각각과도 연결됩니다.

* **제목**&#x200B;은(는) 요청 원본을 나타내는 데 사용됩니다.

  해당 요청에 적용할 수 있는 액세스 권한을 통합하는 데 사용됩니다. 다음에서 가져옵니다.

   * 사용자 계정

     사용자 계정에 직접 지정하는 권한입니다.

   * 해당 사용자와 연계된 모든 그룹 주체

     모든 권한은 사용자가 속한 모든 그룹에 할당됩니다.

  그런 다음 요청된 리소스에 대한 액세스를 허용하거나 거부하는 데 결과가 사용됩니다.

#### 제목에 대한 액세스 권한 목록 컴파일 {#compiling-the-list-of-access-rights-for-a-subject}

CRX에서 제목은 다음에 따라 다릅니다.

* 사용자 계정
* 해당 사용자와 연관된 모든 그룹 주도자

주제에 적용할 수 있는 액세스 권한 목록은 다음 위치에서 구성됩니다.

* 사용자 계정에 직접 할당하는 권한
* 더하기 사용자가 속한 그룹 중 하나에 할당된 모든 권한

![chlimage_1-56](assets/chlimage_1-56.png)

>[!NOTE]
>
>* CRX은 목록을 컴파일할 때 사용자 계층을 고려하지 않습니다.
>* CRX은 그룹을 다른 그룹의 멤버로 포함할 때만 그룹 계층을 사용합니다. 그룹 권한의 자동 상속은 없습니다.
>* 그룹을 지정하는 순서는 액세스 권한에 영향을 주지 않습니다.
>

### 요청 및 액세스 권한 해결 {#resolving-request-and-access-rights}

CRX은 요청을 처리할 때 주체의 액세스 요청을 저장소 노드의 액세스 제어 목록과 비교합니다.

따라서 Linda가 다음 저장소 구조의 `/features` 노드 업데이트를 요청하는 경우:

![chlimage_1-57](assets/chlimage_1-57.png)

### 우선 순위 {#order-of-precedence}

CRX의 액세스 권한은 다음과 같이 평가됩니다.

* 사용자 주도자는 다음에 관계없이 항상 그룹 주도자보다 우선합니다.

   * 액세스 제어 목록의 순서
   * 노드 계층에서 해당 위치

* 지정된 주체에 대해 지정된 노드에 거부가 하나(최대) 있고 항목 진입을 허용하는 거부가 1개 있습니다. 구현은 항상 중복 항목을 지우고 동일한 권한이 허용 및 거부 항목 모두에 나열되지 않도록 합니다.

>[!NOTE]
>
>이 평가 프로세스는 표준 CRX 설치의 리소스 기반 액세스 제어에 적합합니다.

`aUser` 사용자가 `aGroup` 그룹의 멤버인 두 가지 예를 취합니다.

```xml
   + parentNode
     + acl
       + ace: aUser - deny - write
     + childNode
       + acl
         + ace: aGroup - allow - write
       + grandChildNode
```

위의 경우:

* `aUser`에게 `grandChildNode`에 대한 쓰기 권한이 부여되지 않았습니다.

```xml
   + parentNode
     + acl
       + ace: aUser - deny - write
     + childNode
       + acl
         + ace: aGroup - allow - write
         + ace: aUser - deny - write
       + grandChildNode
```

이 경우:

* `aUser`에게 `grandChildNode`에 대한 쓰기 권한이 부여되지 않았습니다.
* `aUser`에 대한 두 번째 ACE가 중복됩니다.

여러 그룹 주체의 액세스 권한은 계층 내 및 단일 액세스 제어 목록 내에서 해당 순서를 기반으로 평가됩니다.

### 모범 사례 {#best-practices}

다음 표에는 몇 가지 권장 사항과 모범 사례가 나와 있습니다.

<table>
 <tbody>
  <tr>
   <td>추천...</td>
   <td>이유...</td>
  </tr>
  <tr>
   <td><i>그룹 사용</i></td>
   <td><p>사용자별로 액세스 권한을 할당하지 마십시오. 다음과 같은 몇 가지 이유가 있습니다.</p>
    <ul>
     <li>그룹보다 사용자가 많으므로 그룹이 구조를 단순화합니다.</li>
     <li>그룹 은 모든 계정에 대한 개요를 제공합니다.</li>
     <li>그룹을 사용하면 상속이 더 간단합니다.</li>
     <li>사용자가 왔다 갔다 합니다. 그룹은 장기적입니다.</li>
    </ul> </td>
  </tr>
  <tr>
   <td><i>긍정적이</i></td>
   <td><p>항상 Allow 문을 사용하여 그룹 주체의 액세스 권한을 지정합니다(가능한 경우). Deny 문을 사용하지 마십시오.</p> <p>그룹 주도자는 계층 내에서, 그리고 단일 액세스 제어 목록 내에서 순서대로 평가됩니다.</p> </td>
  </tr>
  <tr>
   <td><i>단순하게 유지</i></td>
   <td><p>새로운 설치를 구성할 때 시간과 생각을 투자하면 보상이 잘 됩니다.</p> <p>명확한 구조를 적용하면 지속적인 유지 관리 작업이 간소화되어 현재 동료 및/또는 후임 작업자가 구현 중인 내용을 쉽게 이해할 수 있습니다.</p> </td>
  </tr>
  <tr>
   <td><i>테스트</i></td>
   <td>테스트 설치를 사용하여 다양한 사용자와 그룹 간의 관계를 연습하고 이해합니다.</td>
  </tr>
  <tr>
   <td><i>기본 사용자/그룹</i></td>
   <td>설치 후 항상 기본 사용자 및 그룹을 업데이트하여 보안 문제를 방지하십시오.</td>
  </tr>
 </tbody>
</table>

## 사용자 관리 {#user-administration}

표준 대화 상자는 **사용자 관리**&#x200B;에 사용됩니다.

적절한 작업 영역에 로그인해야 다음 두 작업 영역에서 대화 상자에 액세스할 수 있습니다.

* CRX 주 콘솔의 **사용자 관리** 링크
* CRX 탐색기의 **보안** 메뉴

![chlimage_1-58](assets/chlimage_1-58.png)

**속성**

* **사용자 ID**

  CRX에 액세스할 때 계정의 짧은 이름이 사용됩니다.

* **사용자 이름**

  계정의 전체 텍스트 이름.

* **암호**

  이 계정으로 CRX에 액세스할 때 필요합니다.

* **ntlmhash**

  각 새 계정에 대해 자동으로 할당되고 암호가 변경되면 업데이트됩니다.

* 이름, 유형 및 값을 정의하여 새 속성을 추가할 수 있습니다. 각 새 속성에 대해 저장(녹색 확인 기호)을 클릭합니다.

**그룹 구성원**

계정이 속한 모든 그룹이 표시됩니다. 상속됨 열은 다른 그룹의 멤버쉽으로 상속된 멤버쉽을 나타냅니다.

GroupID(사용 가능한 경우)를 클릭하면 해당 그룹에 대한 [그룹 관리](#group-administration)가 열립니다.

**가장자**

가장 기능을 사용하면 사용자가 다른 사용자를 대신하여 작업할 수 있습니다.

즉, 사용자 계정은 해당 계정으로 작동할 수 있는 다른 계정(사용자 또는 그룹)을 지정할 수 있습니다. 즉, user-B가 user-A를 가장하도록 허용되면 user-B는 user-A의 전체 계정 세부 정보(ID, 이름 및 액세스 권한 포함)를 사용하여 작업할 수 있습니다.

이를 통해 가장 계정은 가장 중인 계정을 사용하는 것처럼 작업을 완료할 수 있습니다(예: 부재 중 또는 과도한 로드 단기간 공유).

계정이 다른 계정을 가장하면 보기가 어렵습니다. 로그 파일에는 이벤트가 가장되었다는 사실에 대한 정보가 없습니다. 따라서 user-B가 user-A를 가장하는 경우 모든 이벤트가 user-A가 개인적으로 수행한 것처럼 보일 수 있습니다.

### 사용자 계정 만들기 {#creating-a-user-account}

1. **사용자 관리** 대화 상자를 엽니다.
1. **사용자 만들기**&#x200B;를 클릭합니다.
1. 그런 다음 속성을 입력할 수 있습니다.

   * **UserID**&#x200B;이(가) 계정 이름으로 사용되었습니다.
   * 로그인할 때 **암호**&#x200B;이 필요합니다.
   * 전체 텍스트 이름을 제공하려면 **사용자 이름**&#x200B;을(를) 사용하십시오.
   * 트리 구조를 만드는 데 사용할 수 있는 **중간 경로**.

1. 저장(녹색 확인 기호)을 클릭합니다.
1. 대화 상자가 확장되어 다음과 같은 작업을 수행할 수 있습니다.

   1. **속성**&#x200B;을 구성하십시오.
   1. **그룹 구성원**&#x200B;을 참조하세요.
   1. **가장자**&#x200B;를 정의합니다.

>[!NOTE]
>
>두 사용자 모두 수가 많은 설치에서 새 사용자를 등록할 때 성능이 저하되는 경우가 있습니다.
>
>* 사용자
>* 많은 구성원이 있는 그룹
>

### 사용자 계정 업데이트 {#updating-a-user-account}

1. **사용자 관리** 대화 상자를 사용하여 모든 계정의 목록 보기를 엽니다.
1. 트리 구조를 탐색합니다.
1. 편집을 위해 열 수 있도록 필요한 계정을 클릭합니다.
1. 변경한 다음 해당 항목에 대해 저장(녹색 확인 기호)을 클릭합니다.
1. **닫기**&#x200B;를 클릭하여 완료하거나 **목록...**&#x200B;을 클릭하여 모든 사용자 계정 목록으로 돌아갑니다.

### 사용자 계정 제거 {#removing-a-user-account}

1. **사용자 관리** 대화 상자를 사용하여 모든 계정의 목록 보기를 엽니다.
1. 트리 구조를 탐색합니다.
1. 필요한 계정을 선택하고 **사용자 제거**&#x200B;를 클릭합니다. 계정이 즉시 삭제됩니다.

>[!NOTE]
>
>이렇게 하면 저장소에서 이 사용자에 대한 노드가 제거됩니다.
>
>액세스 권한 항목은 제거되지 않습니다. 이를 통해 기록 무결성을 보장합니다.

### 속성 정의 {#defining-properties}

새 계정 또는 기존 계정에 대해 **속성**&#x200B;을(를) 정의할 수 있습니다.

1. 해당 계정에 대한 **사용자 관리** 대화 상자를 엽니다.
1. **속성** 이름을 정의합니다.
1. 드롭다운 목록에서 **Type**&#x200B;을(를) 선택합니다.
1. **값**&#x200B;을(를) 정의합니다.
1. 새 속성에 대해 저장(녹색 클릭 기호)을 클릭합니다.

휴지통 기호를 사용하여 기존 속성을 삭제할 수 있습니다.

암호를 제외한 속성은 편집할 수 없으며 삭제했다가 다시 만들어야 합니다.

#### 암호 변경 {#changing-the-password}

**암호**&#x200B;은(는) **암호 변경** 링크를 클릭하여 변경할 수 있는 특수 속성입니다.

CRX 탐색기의 **보안** 메뉴에서 자신의 사용자 계정에 대한 암호를 변경할 수도 있습니다.

### 가장자 정의 {#defining-an-impersonator}

새 계정 또는 기존 계정에 대해 가장자를 정의할 수 있습니다.

1. 해당 계정에 대한 **사용자 관리** 대화 상자를 엽니다.
1. 해당 계정을 가장할 수 있는 계정을 지정하십시오.

   찾아보기... 를 사용하여 기존 계정을 선택할 수 있습니다.

1. 새 속성에 대해 저장(녹색 확인 기호)을 클릭합니다.

## 그룹 관리 {#group-administration}

표준 대화 상자는 **그룹 관리**&#x200B;에 사용됩니다.

적절한 작업 영역에 로그인해야 다음 두 작업 영역에서 대화 상자에 액세스할 수 있습니다.

* CRX 주 콘솔의 **그룹 관리** 링크
* CRX 탐색기의 **보안** 메뉴

![chlimage_1-8](assets/chlimage_1-8.jpeg)

**속성**

* **그룹 ID**

  그룹 계정의 약식 이름입니다.

* **사용자 이름**

  그룹 계정의 전체 텍스트 이름.

* 이름, 유형 및 값을 정의하여 새 속성을 추가할 수 있습니다. 각 새 속성에 대해 저장(녹색 확인 기호)을 클릭합니다.

* **구성원**

  사용자 또는 다른 그룹을 이 그룹의 구성원으로 추가할 수 있습니다.

**그룹 구성원**

현재 그룹 계정이 속한 모든 그룹이 표시됩니다. 상속됨 열은 다른 그룹의 멤버쉽으로 상속된 멤버쉽을 나타냅니다.

GroupID를 클릭하면 해당 그룹의 대화 상자가 열립니다.

**구성원**

현재 그룹의 구성원인 모든 계정(사용자 및/또는 그룹)을 나열합니다.

**상속됨** 열은 다른 그룹의 멤버십으로 인해 상속된 멤버십을 나타냅니다.

>[!NOTE]
>
>소유자, 편집자 또는 뷰어 역할이 자산 폴더의 사용자에게 할당되면 새 그룹이 만들어집니다. 역할이 정의된 각 폴더의 그룹 이름이 `mac-default-<foldername>` 형식입니다.

### 그룹 계정 만들기 {#creating-a-group-account}

1. **그룹 관리** 대화 상자를 엽니다.
1. **그룹 만들기**&#x200B;를 클릭합니다.
1. 그런 다음 속성을 입력할 수 있습니다.

   * 전체 텍스트 이름을 제공하려면 **사용자 이름**&#x200B;을(를) 사용하십시오.
   * 트리 구조를 만드는 데 사용할 수 있는 **중간 경로**.

1. 저장(녹색 확인 기호)을 클릭합니다.
1. 대화 상자가 확장되어 다음과 같은 작업을 수행할 수 있습니다.

   1. **속성**&#x200B;을 구성하십시오.
   1. **그룹 구성원**&#x200B;을 참조하세요.
   1. **구성원**&#x200B;을 관리합니다.

### 그룹 계정 업데이트 {#updating-a-group-account}

1. **그룹 관리** 대화 상자를 사용하여 모든 계정의 목록 보기를 엽니다.
1. 트리 구조를 탐색합니다.
1. 편집을 위해 열 수 있도록 필요한 계정을 클릭합니다.
1. 변경한 다음 해당 항목에 대해 저장(녹색 확인 기호)을 클릭합니다.
1. **닫기**&#x200B;를 클릭하여 완료하거나 **목록...**&#x200B;을 클릭하여 모든 그룹 계정 목록으로 돌아갑니다.

### 그룹 계정 제거 {#removing-a-group-account}

1. **그룹 관리** 대화 상자를 사용하여 모든 계정의 목록 보기를 엽니다.
1. 트리 구조를 탐색합니다.
1. 필요한 계정을 선택하고 **그룹 제거**&#x200B;를 클릭합니다. 계정이 즉시 삭제됩니다.

>[!NOTE]
>
>이렇게 하면 저장소에서 이 사용자에 대한 노드가 제거됩니다.
>
>액세스 권한 항목은 제거되지 않습니다. 이를 통해 기록 무결성을 보장합니다.

### 속성 정의 {#defining-properties-1}

새 계정 또는 기존 계정에 대한 등록 정보를 정의할 수 있습니다.

1. 해당 계정의 **그룹 관리** 대화 상자를 엽니다.
1. **속성** 이름을 정의합니다.
1. 드롭다운 목록에서 **Type**&#x200B;을(를) 선택합니다.
1. **값**&#x200B;을(를) 정의합니다.
1. 새 속성에 대해 저장(녹색 확인 기호)을 클릭합니다.

휴지통 기호를 사용하여 기존 속성을 삭제할 수 있습니다.

### 구성원 {#members}

현재 그룹에 구성원을 추가할 수 있습니다.

1. 해당 계정의 **그룹 관리** 대화 상자를 엽니다.
1. 다음 중 하나를 선택합니다.

   * 필요한 구성원의 이름(사용자 또는 그룹 계정)을 입력합니다.
   * 또는 **찾아보기...**&#x200B;를 사용하여 추가할 사용자(사용자 또는 그룹 계정)를 검색하고 선택하십시오.

1. 새 속성에 대해 저장(녹색 확인 기호)을 클릭합니다.

또는 휴지통 기호가 있는 기존 멤버를 삭제합니다.

## 액세스 권한 관리 {#access-right-management}

CRXDE Lite의 **액세스 제어** 탭에서 액세스 제어 정책을 정의하고 관련 권한을 할당할 수 있습니다.

예를 들어, **현재 경로**&#x200B;의 경우 왼쪽 창에서 필요한 리소스를 선택하고 오른쪽 아래 창의 액세스 제어 탭을 선택합니다.

![crx_accesscontrol_tab](assets/crx_accesscontrol_tab.png)

정책은 다음에 따라 분류됩니다.

* **적용 가능한 액세스 제어 정책**

  이러한 정책을 적용할 수 있습니다.

  로컬 정책을 만드는 데 사용할 수 있는 정책입니다. 적용 가능한 정책을 선택하고 추가하면 로컬 정책이 됩니다.

* **로컬 액세스 제어 정책**

  적용한 액세스 제어 정책입니다. 그런 다음 업데이트, 주문 또는 제거할 수 있습니다.

  로컬 정책은 상위에서 상속된 정책을 무시합니다.

* **유효 액세스 제어 정책**

  모든 액세스 요청에 적용되는 액세스 제어 정책입니다. 로컬 정책에서 파생된 집계된 정책과 상위 정책에서 상속된 정책을 표시합니다.

### 정책 선택 {#policy-selection}

다음에 대한 정책을 선택할 수 있습니다.

* **현재 경로**

  위의 예제와 같이 저장소 내의 리소스를 선택합니다. 이 &quot;현재 경로&quot;에 대한 정책이 표시됩니다.

* **저장소**

  저장소 수준 액세스 제어를 선택합니다. 예를 들어 노드가 아닌 저장소에만 관련된 `jcr:namespaceManagement` 권한을 설정할 때 사용합니다.

* **사용자**

  저장소에 등록된 주도자입니다.

  **Principal** 이름을 입력하거나 필드 오른쪽에 있는 아이콘을 클릭하여 **Principal** 선택 대화 상자를 열 수 있습니다.

  **사용자** 또는 **그룹**&#x200B;에 대해 **검색**&#x200B;할 수 있습니다. 결과 목록에서 필요한 주체를 선택한 다음 **확인**&#x200B;을 클릭하여 값을 이전 대화 상자로 다시 전달합니다.

![crx_accesscontrol_selectprincipal](assets/crx_accesscontrol_selectprincipal.png)

>[!NOTE]
>
>관리 Adobe을 간소화하려면 개별 사용자 계정이 아닌 그룹 계정에 액세스 권한을 할당하는 것이 좋습니다.
>
>많은 사용자 계정보다는 몇 개의 그룹을 관리하는 것이 더 쉽습니다.

### 권한 {#privileges}

액세스 제어 항목을 추가할 때 다음 권한을 선택할 수 있습니다(자세한 내용은 [보안 API](https://developer.adobe.com/experience-manager/reference-materials/spec/javax.jcr/javadocs/jcr-2.0/javax/jcr/security/Privilege.html) 참조).

<table>
 <tbody>
  <tr>
   <th><strong>권한 이름</strong></th>
   <th><strong>다음에 대한 권한을 제어합니다.</strong></th>
  </tr>
  <tr>
   <td><code>jcr:read</code></td>
   <td>노드를 검색하고 해당 속성 및 값을 읽습니다.</td>
  </tr>
  <tr>
   <td><code>rep:write</code></td>
   <td>jcr:write 및 jcr:nodeTypeManagement의 Jackrabbit 관련 집계 권한입니다.<br /> </td>
  </tr>
  <tr>
   <td><code>jcr:all</code></td>
   <td>다른 모든 사전 정의된 권한을 포함하는 집계 권한입니다.</td>
  </tr>
  <tr>
   <td><strong>고급</strong></td>
   <td> </td>
  </tr>
  <tr>
   <td><code>crx:replicate</code></td>
   <td>노드 복제를 수행합니다.</td>
  </tr>
  <tr>
   <td><code>jcr:addChildNodes</code></td>
   <td>노드의 하위 노드를 만듭니다.</td>
  </tr>
  <tr>
   <td><code>jcr:lifecycleManagement</code></td>
   <td>노드에서 라이프사이클 작업을 수행합니다.</td>
  </tr>
  <tr>
   <td><code>jcr:lockManagement</code></td>
   <td>노드 잠금 및 잠금 해제, 잠금 새로 고침</td>
  </tr>
  <tr>
   <td><code>jcr:modifyAccessControl</code></td>
   <td>노드의 액세스 제어 정책을 수정합니다.</td>
  </tr>
  <tr>
   <td><code>jcr:modifyProperties</code></td>
   <td>노드 속성을 생성, 수정 및 제거합니다.</td>
  </tr>
  <tr>
   <td><code>jcr:namespaceManagement</code></td>
   <td>네임스페이스 정의를 등록, 등록 취소 및 수정합니다.</td>
  </tr>
  <tr>
   <td><code>jcr:nodeTypeDefinitionManagement</code></td>
   <td>노드 유형 정의를 저장소로 가져옵니다.</td>
  </tr>
  <tr>
   <td><code>jcr:nodeTypeManagement</code></td>
   <td>믹스인 노드 유형을 추가 및 제거하고 노드의 기본 노드 유형을 변경합니다. 또한 Node.addNode 및 XML 가져오기 메서드에 대한 호출도 포함됩니다. 여기서 새 노드의 mixin 또는 기본 형식을 명시적으로 지정합니다.</td>
  </tr>
  <tr>
   <td><code>jcr:readAccessControl</code></td>
   <td>노드의 액세스 제어 정책을 읽습니다.</td>
  </tr>
  <tr>
   <td><code>jcr:removeChildNodes</code></td>
   <td>노드의 하위 노드를 제거합니다.</td>
  </tr>
  <tr>
   <td><code>jcr:removeNode</code></td>
   <td>노드를 제거합니다.</td>
  </tr>
  <tr>
   <td><code>jcr:retentionManagement</code></td>
   <td>노드에 대해 보존 관리 작업을 수행합니다.</td>
  </tr>
  <tr>
   <td><code>jcr:versionManagement</code></td>
   <td>노드에서 버전 관리 작업을 수행합니다.</td>
  </tr>
  <tr>
   <td><code>jcr:workspaceManagement</code></td>
   <td>JCR API를 통한 작업 공간 생성 및 삭제.</td>
  </tr>
  <tr>
   <td><code>jcr:write</code></td>
   <td>다음 항목을 포함하는 집계 권한입니다. <br /> - jcr:modifyProperties<br /> - jcr:addChildNodes<br /> - jcr:removeNode<br /> - jcr:removeChildNodes</td>
  </tr>
  <tr>
   <td><code>rep:privilegeManagement</code></td>
   <td>새 권한을 등록합니다.</td>
  </tr>
 </tbody>
</table>

### 새 권한 등록 {#registering-new-privileges}

새 권한을 등록할 수도 있습니다.

1. 도구 모음에서 **도구**&#x200B;를 선택한 다음 **권한**&#x200B;을 선택하여 현재 등록된 권한을 표시합니다.

   ![ac_privileges](assets/ac_privileges.png)

1. 권한을 정의할 수 있도록 **권한 등록** 아이콘(**+**)을 사용하십시오.

   ![ac_privilegeregister](assets/ac_privilegeregister.png)

1. 저장하려면 **확인**&#x200B;을 클릭하세요. 이제 권한을 선택할 수 있습니다.

### 액세스 제어 항목 추가 {#adding-an-access-control-entry}

1. 리소스를 선택하고 **액세스 제어** 탭을 엽니다.

1. 새 **로컬 액세스 제어 정책**&#x200B;을 추가하려면 **적용 가능한 액세스 제어 정책** 목록 오른쪽에 있는 **+** 아이콘을 클릭하십시오.

   ![crx_accesscontrol_applicable](assets/crx_accesscontrol_applicable.png)

1. **로컬 액세스 제어 정책:**&#x200B;에 새 항목이 나타납니다.

   ![crx_accesscontrol_newlocal](assets/crx_accesscontrol_newlocal.png)

1. 항목을 추가할 수 있도록 **+** 아이콘을 클릭합니다.

   ![crx_accesscontrol_addentry](assets/crx_accesscontrol_addentry.png)

   >[!NOTE]
   >
   >현재 빈 문자열을 지정하려면 해결 방법이 필요합니다.
   >
   >이를 위해 `""`을(를) 사용해야 합니다.

1. 액세스 제어 정책을 정의하고 **확인**&#x200B;을 클릭하여 저장합니다. 새 정책:

   * **로컬 액세스 제어 정책**&#x200B;에 나열됨
   * 변경 사항은 **유효 액세스 제어 정책**&#x200B;에 반영됩니다.

CRX은 선택 내용을 확인합니다. 지정된 주체에 대해 지정된 노드에 거부 항목과 허용 항목이 각각 하나씩 있습니다. 구현은 항상 중복 항목을 지우고 동일한 권한이 허용 및 거부 항목 모두에 나열되지 않도록 합니다.

### 로컬 액세스 제어 정책 순서 지정 {#ordering-local-access-control-policies}

목록의 순서는 정책이 적용되는 순서를 나타냅니다.

1. **로컬 액세스 제어 정책**&#x200B;의 테이블에서 필요한 항목을 선택하고 테이블의 새 위치로 끕니다.

   ![crx_accesscontrol_reorder](assets/crx_accesscontrol_reorder.png)

1. 변경 내용은 **Local** 및 **유효 액세스 제어 정책**&#x200B;에 대한 테이블에 모두 표시됩니다.

### 액세스 제어 정책 제거 {#removing-an-access-control-policy}

1. **로컬 액세스 제어 정책** 테이블에서 항목 오른쪽에 있는 빨간색 아이콘(-)을 클릭합니다.
1. **Local** 및 **유효 액세스 제어 정책**&#x200B;에 대한 테이블 모두에서 항목이 제거되었습니다.

### 액세스 제어 정책 테스트 {#testing-an-access-control-policy}

1. CRXDE Lite 도구 모음에서 **도구**&#x200B;를 선택한 다음 **액세스 제어 테스트...**&#x200B;를 선택합니다.
1. 오른쪽 상단 창에 새 대화 상자가 열립니다. 테스트할 **경로** 및/또는 **사용자**&#x200B;을(를) 선택하십시오.
1. 선택 결과를 보려면 **테스트**&#x200B;를 클릭하십시오.

   ![crx_accesscontrol_test](assets/crx_accesscontrol_test.png)
