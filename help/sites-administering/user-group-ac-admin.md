---
title: 사용자, 그룹 및 액세스 권한 관리
seo-title: User, Group and Access Rights Administration
description: AEM의 사용자, 그룹 및 액세스 권한 관리에 대해 알아봅니다.
seo-description: Learn about user, group and access rights administration in AEM.
uuid: 26d7bb25-5a38-43c6-bd6a-9ddba582c60f
products: SG_EXPERIENCEMANAGER/6.5/SITES
topic-tags: Security
content-type: reference
discoiquuid: 66674e47-d19f-418f-857f-d91cf8660b6d
docset: aem65
exl-id: 5808b8f9-9b37-4970-b5c1-4d33404d3a8b
feature: Security
source-git-commit: 2bae11eafb875f01602c39c0dba00a888e11391a
workflow-type: tm+mt
source-wordcount: '3120'
ht-degree: 1%

---

# 사용자, 그룹 및 액세스 권한 관리{#user-group-and-access-rights-administration}

CRX 저장소에 대한 액세스 활성화에는 다음과 같은 몇 가지 주제가 포함되어 있습니다.

* [액세스 권한](#how-access-rights-are-evaluated)  - 액세스 권한 정의 및 평가 방법에 대한 개념입니다
* [사용자 관리](#user-administration)  - 액세스에 사용되는 개별 계정 관리
* [그룹 관리](#group-administration)  - 그룹을 구성하여 사용자 관리 간소화
* [액세스 권한 관리](#access-right-management)  - 이러한 사용자와 그룹이 리소스에 액세스할 수 있는 방법을 제어하는 정책 정의

기본 요소는 다음과 같습니다.

**사용자** 계정CRX는 사용자 계정에 저장된 세부 사항에 따라 사용자(해당 사용자 또는 다른 응용 프로그램)를 식별 및 확인하여 액세스 권한을 인증합니다.

CRX에서 모든 사용자 계정은 작업 공간의 노드입니다. CRX 사용자 계정에는 다음 속성이 있습니다.

* CRX의 사용자 하나를 나타냅니다.
* 사용자 이름과 암호가 들어 있습니다.
* 해당 작업 공간에 적용할 수 있습니다.
* 하위 사용자를 가질 수 없습니다. 계층적 액세스 권한의 경우 그룹을 사용해야 합니다.

* 사용자 계정에 대한 액세스 권한을 지정할 수 있습니다.

   그러나 관리를 간소화하려면 대부분의 경우 그룹 계정에 액세스 권한을 할당하는 것이 좋습니다. 각 개별 사용자에 대한 액세스 권한을 할당하면 관리가 매우 어렵습니다. 단, 하나 또는 두 개의 인스턴스만 있을 때 특정 시스템 사용자가 예외입니다.

**그룹** 계정 그룹 계정은 사용자 및/또는 기타 그룹의 컬렉션입니다. 그룹에 할당된 액세스 권한이 해당 그룹의 모든 사용자에게 자동으로 적용되므로 관리를 간소화하는 데 사용됩니다. 사용자는 그룹에 속하지 않아도 되지만 종종 여러 그룹에 속합니다.

CRX에서 그룹에는 다음 속성이 있습니다.

* 공통 액세스 권한을 가진 사용자 그룹을 나타냅니다. 예를 들어 작성자 또는 개발자가 있습니다.
* 해당 작업 공간에 적용할 수 있습니다.
* 회원이 있을 수 있습니다. 개별 사용자 또는 다른 그룹일 수 있습니다.
* 멤버 관계를 사용하여 계층적 그룹화를 수행할 수 있습니다. 리포지토리의 다른 그룹 바로 아래에 그룹을 배치할 수 없습니다.
* 모든 그룹 구성원의 액세스 권한을 정의할 수 있습니다.

**액세스** 권한 CRX는 액세스 권한을 사용하여 저장소의 특정 영역에 대한 액세스를 제어합니다.

이 작업은 리포지토리의 리소스(노드 또는 경로)에 대한 액세스를 허용 또는 거부할 권한을 할당하여 수행됩니다. 다양한 권한을 지정할 수 있으므로, 현재 요청에 적용할 수 있는 조합을 결정하도록 평가되어야 합니다.

CRX를 사용하면 사용자 및 그룹 계정 모두에 대한 액세스 권한을 구성할 수 있습니다. 그런 다음 두 가지 평가 기본원칙도 똑같이 적용된다.

## 액세스 권한을 평가하는 방법 {#how-access-rights-are-evaluated}

>[!NOTE]
>
>CRX는 JSR-283](https://www.adobe.io/experience-manager/reference-materials/spec/jcr/2.0/16_Access_Control_Management.html)에 의해 정의된 대로 [액세스 제어를 구현합니다.
>
>CRX 저장소의 표준 설치는 리소스 기반 액세스 제어 목록을 사용하도록 구성됩니다. 이는 JSR-283 액세스 제어의 가능한 구현과 Jackrabbit이 있는 구현 중 하나입니다.

### 주제 및 주도자 {#subjects-and-principals}

CRX는 액세스 권한을 평가할 때 두 가지 주요 개념을 사용합니다.

* **주체**&#x200B;는 액세스 권한을 가지고 있는 엔터티입니다. 주도자는 다음과 같습니다.

   * 사용자 계정
   * 그룹 계정

      사용자 계정이 하나 이상의 그룹에 속하는 경우 해당 그룹 주도자도 각각 연결됩니다.

* **subject**&#x200B;는 요청의 소스를 나타내는 데 사용됩니다.

   이 변수는 해당 요청에 적용할 수 있는 액세스 권한을 통합하는 데 사용됩니다. 다음 항목에서 가져옵니다.

   * 사용자 주체

      사용자 계정에 직접 할당하는 권한.

   * 해당 사용자와 연결된 모든 그룹 주체

      사용자가 속한 그룹에 할당된 모든 권한.
   그런 다음 요청된 리소스에 대한 액세스를 허용하거나 거부하는 데 결과를 사용합니다.

#### 제목에 대한 액세스 권한 목록 컴파일 {#compiling-the-list-of-access-rights-for-a-subject}

CRX에서 제목은 다음에 따라 다릅니다.

* 사용자 주체
* 해당 사용자와 연결된 모든 그룹 주체

제목에 적용할 수 있는 액세스 권한 목록은 다음 항목에서 구성됩니다.

* 사용자 계정에 직접 할당하는 권한
* 및 사용자가 속한 그룹에 할당된 모든 권한

![chlimage_1-56](assets/chlimage_1-56.png)

>[!NOTE]
>
>* CRX는 목록을 컴파일할 때 사용자 계층을 고려하지 않습니다.
>* CRX에서는 그룹을 다른 그룹의 구성원으로 포함하는 경우에만 그룹 계층을 사용합니다. 그룹 권한의 자동 상속은 없습니다.
>* 그룹을 지정하는 순서는 액세스 권한에 영향을 주지 않습니다.

>


### 요청 및 액세스 권한 해결 {#resolving-request-and-access-rights}

CRX가 요청을 처리할 때 주체의 액세스 요청을 저장소 노드의 액세스 제어 목록과 비교합니다.

따라서 Linda가 다음 저장소 구조에서 `/features` 노드를 업데이트하도록 요청하는 경우:

![chlimage_1-57](assets/chlimage_1-57.png)

### 우선순위 {#order-of-precedence}

CRX의 액세스 권한은 다음과 같이 평가됩니다.

* 사용자 주도자는 항상 다음과 관계없이 그룹 주도자보다 우선합니다.

   * 액세스 제어 목록의 순서
   * 노드 계층에서의 위치

* 주어진 주도자에 대해 주어진 노드에 대한 입력 허용(최대) 1 거부 및 1이 있습니다. 구현은 항상 중복 항목을 지우고 허용 및 거부 항목 모두에 동일한 권한이 나열되지 않는지 확인합니다.

>[!NOTE]
>
>이 평가 프로세스는 표준 CRX 설치의 리소스 기반 액세스 제어에 적합합니다.

사용자 `aUser`이(가) `aGroup` 그룹의 멤버인 두 개의 예를 살펴보겠습니다.

```xml
   + parentNode
     + acl
       + ace: aUser - deny - write
     + childNode
       + acl
         + ace: aGroup - allow - write
       + grandChildNode
```

위의 경우:

* `aUser` 에 대한 쓰기 권한이 없습니다 `grandChildNode`.

```xml
   + parentNode
     + acl
       + ace: aUser - deny - write
     + childNode
       + acl
         + ace: aGroup - allow - write
         + ace: aUser - deny - write
       + grandChildNode
```

이 경우:

* `aUser` 에 대한 쓰기 권한이 없습니다 `grandChildNode`.
* `aUser`의 두 번째 ACE가 중복됩니다.

여러 그룹 주도자의 액세스 권한은 계층 내에서 단일 액세스 제어 목록 내에서 순서에 따라 평가됩니다.

### 우수 사례 {#best-practices}

다음 표에는 몇 가지 권장 사항 및 우수 사례가 나와 있습니다.

<table>
 <tbody>
  <tr>
   <td>추천...</td>
   <td>이유...</td>
  </tr>
  <tr>
   <td><i>그룹 사용</i></td>
   <td><p>사용자별로 액세스 권한을 할당하지 마십시오. 다음과 같은 몇 가지 이유가 있습니다.</p>
    <ul>
     <li>그룹보다 사용자가 많으므로 그룹은 구조를 단순화합니다.</li>
     <li>그룹은 모든 계정에 대한 개요를 제공하는 데 도움이 됩니다.</li>
     <li>그룹은 상속이 간단합니다.</li>
     <li>사용자가 와서 이동합니다. 그룹은 장기적입니다.</li>
    </ul> </td>
  </tr>
  <tr>
   <td><i>긍정적이 되다</i></td>
   <td><p>그룹 주도자의 액세스 권한을 지정하려면 항상 Allow 문을 사용하십시오(가능한 경우). Deny 문을 사용하지 마십시오.</p> <p>그룹 주도자는 단일 액세스 제어 목록 내의 계층 및 순서 내에서 순서대로 평가됩니다.</p> </td>
  </tr>
  <tr>
   <td><i>단순하게 유지</i></td>
   <td><p>얼마 동안 투자하고 새 설치를 구성할 때 충분한 보상을 받을 것이라고 생각했다.</p> <p>명확한 구조를 적용하면 지속적인 유지 관리 및 관리를 간소화할 수 있으므로 현재 동료와 향후 후임자가 구현되는 내용을 쉽게 이해할 수 있습니다.</p> </td>
  </tr>
  <tr>
   <td><i>테스트</i></td>
   <td>테스트 설치를 사용하여 다양한 사용자와 그룹 간의 관계를 설명하고 이해할 수 있습니다.</td>
  </tr>
  <tr>
   <td><i>기본 사용자/그룹</i></td>
   <td>보안 문제를 방지하기 위해 항상 설치 후 기본 사용자 및 그룹을 즉시 업데이트합니다.</td>
  </tr>
 </tbody>
</table>

## 사용자 관리 {#user-administration}

**사용자 관리**&#x200B;에 표준 대화 상자가 사용됩니다.

적절한 작업 공간에 로그인해야 다음 두 작업 모두에서 대화 상자에 액세스할 수 있습니다.

* CRX의 기본 콘솔에서 **사용자 관리** 링크
* CRX 탐색기의 **보안** 메뉴

![chlimage_1-58](assets/chlimage_1-58.png)

**속성**

* **UserID**

   CRX에 액세스할 때 사용되는 계정에 대한 짧은 이름입니다.

* **주체 이름**

   계정의 전체 텍스트 이름입니다.

* **암호**

   이 계정으로 CRX에 액세스할 때 필요합니다.

* **ntlmhash**

   각 새 계정에 대해 자동으로 할당되며, 암호가 변경될 때 업데이트됩니다.

* 이름, 유형 및 값을 정의하여 새 속성을 추가할 수 있습니다. 각 새 속성에 대해 저장(녹색 눈금 기호)을 클릭합니다.

**그룹 구성원**

계정이 속한 모든 그룹이 표시됩니다. 상속됨 열은 다른 그룹의 멤버십으로 인해 상속된 멤버십을 나타냅니다.

GroupID(사용 가능한 경우)를 클릭하면 해당 그룹에 대한 [그룹 관리](#group-administration)가 열립니다.

**가장한 사람**

가장 기능을 사용하면 사용자는 다른 사용자를 대신하여 작업할 수 있습니다.

즉, 사용자 계정은 해당 계정으로 작업할 수 있는 다른 계정(사용자 또는 그룹)을 지정할 수 있습니다. 즉, 사용자-B가 사용자-A를 가장할 수 있는 경우, 사용자-B는 사용자-A의 전체 계정 세부 정보(ID, 이름 및 액세스 권한 포함)를 사용하여 작업을 수행할 수 있습니다.

이를 통해 가장자 계정이 가장하고 있는 계정을 사용하는 것처럼 작업을 완료할 수 있습니다. 예를 들어, 부재 중 또는 과도한 로드 단말을 공유하는 경우

만약 한 계좌가 다른 계좌에서 가장하면, 그것은 보기 매우 어렵다. 로그 파일에는 이벤트에서 가장이 발생했는지에 대한 정보가 없습니다. 따라서 사용자-B를 가장하는 경우 - 모든 이벤트는 사용자-A에 의해 개인적으로 수행된 것처럼 표시됩니다.

### 사용자 계정 만들기 {#creating-a-user-account}

1. **사용자 관리** 대화 상자를 엽니다.
1. **사용자 만들기**&#x200B;를 클릭합니다.
1. 그런 다음 등록 정보를 입력할 수 있습니다.

   * **** 계정 이름으로 사용되는 UserID입니다.
   * **** 로그인할 때 필요한 암호입니다.
   * **주체 이름** 을 사용하여 전체 텍스트 이름을 제공합니다.
   * **트리** 구조를 구성하는 데 사용할 수 있는 중간 경로.

1. 저장(녹색 확인 표시 기호)을 클릭합니다.
1. 대화 상자가 확장되어 다음 작업을 수행할 수 있습니다.

   1. **속성**&#x200B;을 구성합니다.
   1. **그룹 멤버십**&#x200B;을 참조하십시오.
   1. **가장자**&#x200B;를 정의합니다.

>[!NOTE]
>
>둘 다 많은 수의 새 사용자를 설치에 등록할 때 성능이 저하되는 경우가 있습니다.
>
>* 사용자
>* 그룹 많은 멤버와

>


### 사용자 계정 업데이트 {#updating-a-user-account}

1. **사용자 관리** 대화 상자에서 모든 계정의 목록 보기를 엽니다.
1. 트리 구조를 탐색합니다.
1. 편집하려면 필요한 계정을 클릭합니다.
1. 변경한 다음 해당 항목에 대해 저장(녹색 눈금 기호)을 클릭합니다.
1. **Close** 를 클릭하여 마치거나 **목록... 을 클릭하십시오.모든 사용자 계정 목록으로 돌아가려면** 를 클릭합니다.

### 사용자 계정 제거 {#removing-a-user-account}

1. **사용자 관리** 대화 상자에서 모든 계정의 목록 보기를 엽니다.
1. 트리 구조를 탐색합니다.
1. 필요한 계정을 선택하고 **사용자 제거**; 계정이 즉시 삭제됩니다.

>[!NOTE]
>
>저장소에서 이 주체에 대한 노드가 제거됩니다.
>
>액세스 권한 항목은 제거되지 않습니다. 이렇게 하면 역사적인 무결성을 보장합니다.

### 속성 정의 {#defining-properties}

새 계정 또는 기존 계정에 대해 **속성**&#x200B;을 정의할 수 있습니다.

1. 해당 계정에 대해 **사용자 관리** 대화 상자를 엽니다.
1. **속성** 이름을 정의합니다.
1. 드롭다운 목록에서 **유형**&#x200B;을 선택합니다.
1. **값**&#x200B;을 정의합니다.
1. 새 속성에 대해 저장(녹색 클릭 기호)을 클릭합니다.

기존 속성은 휴지통 심벌로 삭제할 수 있습니다.

암호를 제외하고 속성을 편집할 수 없으므로 속성을 삭제하고 다시 만들어야 합니다.

#### 암호 변경 {#changing-the-password}

**암호**&#x200B;는 **암호 변경** 링크를 클릭하여 변경할 수 있는 특수 속성입니다.

또한 CRX Explorer의 **보안** 메뉴에서 암호를 고유한 사용자 계정으로 변경할 수 있습니다.

### 가장자 정의 {#defining-an-impersonator}

새 계정 또는 기존 계정에 대해 가장자를 정의할 수 있습니다.

1. 해당 계정에 대해 **사용자 관리** 대화 상자를 엽니다.
1. 해당 계정을 가장할 수 있는 계정을 지정하십시오.

   찾아보기... 를 사용하여 기존 계정을 선택할 수 있습니다.

1. 새 속성에 대해 저장(녹색 눈금 기호)을 클릭합니다.

## 그룹 관리 {#group-administration}

**그룹 관리**&#x200B;에 표준 대화 상자가 사용됩니다.

적절한 작업 공간에 로그인해야 다음 두 작업 모두에서 대화 상자에 액세스할 수 있습니다.

* CRX의 기본 콘솔에서 **그룹 관리** 링크
* CRX 탐색기의 **보안** 메뉴

![chlimage_1-8](assets/chlimage_1-8.jpeg)

**속성**

* **GroupID**

   그룹 계정의 짧은 이름입니다.

* **주체 이름**

   그룹 계정의 전체 텍스트 이름입니다.

* 이름, 유형 및 값을 정의하여 새 속성을 추가할 수 있습니다. 각 새 속성에 대해 저장(녹색 눈금 기호)을 클릭합니다.

* **구성원**

   사용자 또는 다른 그룹을 이 그룹의 구성원으로 추가할 수 있습니다.

**그룹 구성원**

현재 그룹 계정이 속한 모든 그룹이 표시됩니다. 상속됨 열은 다른 그룹의 멤버십으로 인해 상속된 멤버십을 나타냅니다.

GroupID를 클릭하면 해당 그룹에 대한 대화 상자가 열립니다.

**구성원**

현재 그룹의 구성원인 모든 계정(사용자 및/또는 그룹)을 나열합니다.

**상속됨** 열은 다른 그룹의 멤버십으로 인해 상속된 멤버십을 나타냅니다.

>[!NOTE]
>
>소유자, 편집기 또는 뷰어 역할이 자산 폴더의 사용자에게 할당되면 새 그룹이 만들어집니다. 그룹 이름은 역할이 정의된 각 폴더의 `mac-default-<foldername>` 형식입니다.

### 그룹 계정 만들기 {#creating-a-group-account}

1. **그룹 관리** 대화 상자를 엽니다.
1. **그룹 만들기**&#x200B;를 클릭합니다.
1. 그런 다음 등록 정보를 입력할 수 있습니다.

   * **주체 이름** 을 사용하여 전체 텍스트 이름을 제공합니다.
   * **트리** 구조를 구성하는 데 사용할 수 있는 중간 경로.

1. 저장(녹색 확인 표시 기호)을 클릭합니다.
1. 대화 상자가 확장되어 다음 작업을 수행할 수 있습니다.

   1. **속성**&#x200B;을 구성합니다.
   1. **그룹 멤버십**&#x200B;을 참조하십시오.
   1. **멤버**&#x200B;를 관리합니다.

### 그룹 계정 업데이트 {#updating-a-group-account}

1. **그룹 관리** 대화 상자에서 모든 계정의 목록 보기를 엽니다.
1. 트리 구조를 탐색합니다.
1. 편집하려면 필요한 계정을 클릭합니다.
1. 변경한 다음 해당 항목에 대해 저장(녹색 눈금 기호)을 클릭합니다.
1. **Close** 를 클릭하여 마치거나 **목록... 을 클릭하십시오.모든 그룹 계정 목록으로 돌아가려면** 를 클릭합니다.

### 그룹 계정 제거 {#removing-a-group-account}

1. **그룹 관리** 대화 상자에서 모든 계정의 목록 보기를 엽니다.
1. 트리 구조를 탐색합니다.
1. 필요한 계정을 선택하고 **그룹 제거**; 계정이 즉시 삭제됩니다.

>[!NOTE]
>
>저장소에서 이 주체에 대한 노드가 제거됩니다.
>
>액세스 권한 항목은 제거되지 않습니다. 이렇게 하면 역사적인 무결성을 보장합니다.

### 속성 정의 {#defining-properties-1}

새 계정 또는 기존 계정에 대해 속성 을 정의할 수 있습니다.

1. 해당 계정에 대해 **그룹 관리** 대화 상자를 엽니다.
1. **속성** 이름을 정의합니다.
1. 드롭다운 목록에서 **유형**&#x200B;을 선택합니다.
1. **값**&#x200B;을 정의합니다.
1. 새 속성에 대해 저장(녹색 눈금 기호)을 클릭합니다.

기존 속성은 휴지통 심벌로 삭제할 수 있습니다.

### 구성원 {#members}

현재 그룹에 구성원을 추가할 수 있습니다.

1. 해당 계정에 대해 **그룹 관리** 대화 상자를 엽니다.
1. 다음 중 하나를 선택합니다.

   * 필요한 구성원의 이름(사용자 또는 그룹 계정)을 입력합니다.
   * 또는 **찾아보기..** 을(를) 검색하고 추가할 주체(사용자 또는 그룹 계정)를 선택합니다.

1. 새 속성에 대해 저장(녹색 눈금 기호)을 클릭합니다.

또는 휴지통 기호가 있는 기존 멤버를 삭제합니다.

## 액세스 권한 관리 {#access-right-management}

CRXDE Lite의 **액세스 제어** 탭을 사용하여 액세스 제어 정책을 정의하고 관련 권한을 할당할 수 있습니다.

예를 들어, **현재 경로**&#x200B;의 경우 왼쪽 창에서 오른쪽 아래 창의 액세스 제어 탭을 선택합니다.

![crx_accesscontrol_tab](assets/crx_accesscontrol_tab.png)

정책은 다음과 같이 분류됩니다.

* **적용 가능한 액세스 제어 정책**

   이러한 정책은 적용될 수 있습니다.

   로컬 정책을 만드는 데 사용할 수 있는 정책입니다. 적용 가능한 정책을 선택하고 추가하면 로컬 정책이 됩니다.

* **로컬 액세스 제어 정책**

   적용한 액세스 제어 정책입니다. 그런 다음 업데이트, 주문 또는 제거할 수 있습니다.

   로컬 정책은 상위에서 상속된 모든 정책을 덮어씁니다.

* **유효 액세스 제어 정책**

   이는 모든 액세스 요청에 대해 현재 적용되는 액세스 제어 정책입니다. 로컬 정책 모두에서 파생된 집계 정책과 상위에서 상속된 모든 정책을 보여 줍니다.

### 정책 선택 {#policy-selection}

정책을 선택할 수 있는 대상:

* **현재 경로**

   위의 예제에서 저장소 내의 리소스를 선택합니다. 이 &quot;현재 경로&quot;에 대한 정책이 표시됩니다.

* **저장소**

   저장소 수준 액세스 제어를 선택합니다. 예를 들어, `jcr:namespaceManagement` 권한을 설정할 때 노드가 아니라 저장소에만 해당됩니다.

* **사용자**

   리포지토리에 등록된 주체.

   **Principal** 이름을 입력하거나 필드 오른쪽의 아이콘을 클릭하여 **Select Principal** 대화 상자를 열 수 있습니다.

   **User** 또는 **Group**&#x200B;에 대해 **검색**&#x200B;할 수 있습니다. 결과 목록에서 필요한 주도자를 선택한 다음 **확인**&#x200B;을 클릭하여 값을 이전 대화 상자로 다시 전달합니다.

![crx_accesscontrol_selectprincipal](assets/crx_accesscontrol_selectprincipal.png)

>[!NOTE]
>
>관리를 간소화하려면 개별 사용자 계정이 아닌 그룹 계정에 액세스 권한을 할당하는 것이 좋습니다.
>
>여러 사용자 계정이 아닌 몇 개의 그룹을 관리하는 것이 더 쉽습니다.

### 권한 {#privileges}

액세스 제어 항목을 추가할 때 다음 권한을 선택할 수 있습니다(자세한 내용은 [보안 API](https://docs.adobe.com/docs/en/spec/javax.jcr/javadocs/jcr-2.0/javax/jcr/security/Privilege.html) 참조).

<table>
 <tbody>
  <tr>
   <th><strong>권한 이름</strong></th>
   <th><strong>...의 권한을 제어하는 것.</strong></th>
  </tr>
  <tr>
   <td><code>jcr:read</code></td>
   <td>노드를 검색하고 해당 속성 및 값을 읽습니다.</td>
  </tr>
  <tr>
   <td><code>rep:write</code></td>
   <td>jcr:write 및 jcr:nodeTypeManagement의 jackrabbit 특정 집계 권한입니다.<br /> </td>
  </tr>
  <tr>
   <td><code>jcr:all</code></td>
   <td>미리 정의된 다른 모든 권한을 포함하는 집계 권한입니다.</td>
  </tr>
  <tr>
   <td><strong>고급</strong></td>
   <td> </td>
  </tr>
  <tr>
   <td><code>crx:replicate</code></td>
   <td>노드의 복제를 수행합니다.</td>
  </tr>
  <tr>
   <td><code>jcr:addChildNodes</code></td>
   <td>노드의 하위 노드를 생성합니다.</td>
  </tr>
  <tr>
   <td><code>jcr:lifecycleManagement</code></td>
   <td>노드에서 라이프사이클 작업을 수행합니다.</td>
  </tr>
  <tr>
   <td><code>jcr:lockManagement</code></td>
   <td>노드 잠금 및 잠금 해제; 잠금을 새로 고칩니다.</td>
  </tr>
  <tr>
   <td><code>jcr:modifyAccessControl</code></td>
   <td>노드의 액세스 제어 정책을 수정합니다.</td>
  </tr>
  <tr>
   <td><code>jcr:modifyProperties</code></td>
   <td>노드의 속성을 생성, 수정 및 제거합니다.</td>
  </tr>
  <tr>
   <td><code>jcr:namespaceManagement</code></td>
   <td>네임스페이스 정의를 등록, 등록 취소 및 수정합니다.</td>
  </tr>
  <tr>
   <td><code>jcr:nodeTypeDefinitionManagement</code></td>
   <td>저장소에 노드 유형 정의를 가져옵니다.</td>
  </tr>
  <tr>
   <td><code>jcr:nodeTypeManagement</code></td>
   <td>mixin 노드 유형을 추가 및 제거하고 노드의 기본 노드 유형을 변경합니다. 여기에는 새 노드의 mixin 또는 기본 유형이 명시적으로 지정된 Node.addNode 및 XML 가져오기 메서드에 대한 모든 호출도 포함됩니다.</td>
  </tr>
  <tr>
   <td><code>jcr:readAccessControl</code></td>
   <td>노드의 액세스 제어 정책을 읽습니다.</td>
  </tr>
  <tr>
   <td><code>jcr:removeChildNodes</code></td>
   <td>노드의 하위 노드를 제거합니다.</td>
  </tr>
  <tr>
   <td><code>jcr:removeNode</code></td>
   <td>노드를 제거합니다.</td>
  </tr>
  <tr>
   <td><code>jcr:retentionManagement</code></td>
   <td>노드에서 보존 관리 작업을 수행합니다.</td>
  </tr>
  <tr>
   <td><code>jcr:versionManagement</code></td>
   <td>노드에서 버전 관리 작업을 수행합니다.</td>
  </tr>
  <tr>
   <td><code>jcr:workspaceManagement</code></td>
   <td>JCR API를 통해 작업 공간을 만들고 삭제합니다.</td>
  </tr>
  <tr>
   <td><code>jcr:write</code></td>
   <td>이 권한은 <br /> - jcr:modifyProperties<br /> - jcr:addChildNodes<br /> - jcr:removeNode<br /> - jcr:removeChildNodes를 포함하는 집계 권한입니다.</td>
  </tr>
  <tr>
   <td><code>rep:privilegeManagement</code></td>
   <td>새 권한을 등록합니다.</td>
  </tr>
 </tbody>
</table>

### 새 권한 등록 {#registering-new-privileges}

새 권한을 등록할 수도 있습니다.

1. 도구 모음에서 **도구**&#x200B;를 선택한 다음 **권한**&#x200B;을 선택하여 현재 등록된 권한을 표시합니다.

   ![ac_privileges](assets/ac_privileges.png)

1. **권한 등록** 아이콘(**+**)을 사용하여 대화 상자를 열고 새 권한을 정의합니다.

   ![ac_privilegeregister](assets/ac_privilegeregister.png)

1. **확인**&#x200B;을 클릭하여 저장합니다. 이제 이 권한을 선택할 수 있습니다.

### 액세스 제어 항목 추가 {#adding-an-access-control-entry}

1. 리소스를 선택하고 **Access Control** 탭을 엽니다.

1. 새 **로컬 액세스 제어 정책**&#x200B;을 추가하려면 **적용 가능한 액세스 제어 정책** 목록 오른쪽에 있는 **+** 아이콘을 클릭합니다.

   ![crx_accesscontrol_acceptable](assets/crx_accesscontrol_applicable.png)

1. **로컬 액세스 제어 정책:** 아래에 새 항목이 나타납니다.

   ![crx_accesscontrol_newlocal](assets/crx_accesscontrol_newlocal.png)

1. **+** 아이콘을 클릭하여 새 항목을 추가합니다.

   ![crx_accesscontrol_addentry](assets/crx_accesscontrol_addentry.png)

   >[!NOTE]
   >
   >현재 빈 문자열을 지정하는 데 해결 방법이 필요합니다.
   >
   >이를 위해서는 &quot;&quot;를 사용해야 합니다.

1. 액세스 제어 정책을 정의하고 **확인**&#x200B;을 클릭하여 저장합니다. 새 정책은 다음과 같습니다.

   * **로컬 액세스 제어 정책** 아래에 나열됩니다.
   * 변경 내용은 **유효 액세스 제어 정책**&#x200B;에 반영됩니다.

CRX가 선택 항목의 유효성을 검사합니다. 주어진 주도자에 대해 주어진 노드에 대한 입력 허용(최대) 1 거부 및 1이 있습니다. 구현은 항상 중복 항목을 지우고 허용 및 거부 항목 모두에 동일한 권한이 나열되지 않는지 확인합니다.

### 로컬 액세스 제어 정책 순서 지정 {#ordering-local-access-control-policies}

목록의 순서는 정책이 적용되는 순서를 나타냅니다.

1. **로컬 액세스 제어 정책** 테이블에서 필요한 항목을 선택하고 테이블의 새 위치로 드래그합니다.

   ![crx_accesscontrol_reorder](assets/crx_accesscontrol_reorder.png)

1. 변경 내용은 **Local** 및 **유효한 액세스 제어 정책**&#x200B;에 대한 두 표에 모두 표시됩니다.

### 액세스 제어 정책 제거 {#removing-an-access-control-policy}

1. **로컬 액세스 제어 정책** 테이블의 항목 오른쪽에 있는 빨간색 아이콘(-)을 클릭합니다.
1. **Local**&#x200B;과 **Effective Access Control Policy**&#x200B;의 두 테이블에서 항목이 제거됩니다.

### 액세스 제어 정책 테스트 {#testing-an-access-control-policy}

1. CRXDE Lite 도구 모음에서 **도구**&#x200B;를 선택한 다음 **액세스 제어 테스트...**.
1. 오른쪽 상단 창에 새 대화 상자가 열립니다. 테스트할 **경로** 및/또는 **주체**&#x200B;를 선택하십시오.
1. **테스트**&#x200B;를 클릭하여 선택 결과를 확인합니다.

   ![crx_accesscontrol_test](assets/crx_accesscontrol_test.png)
